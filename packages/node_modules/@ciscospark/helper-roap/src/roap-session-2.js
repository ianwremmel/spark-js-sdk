/* eslint-disable require-jsdoc */

import {Exception} from '@ciscospark/common';

import {RoapTransaction} from './roap-transaction';

class RoapException extends Exception {}
class InvalidStateError extends RoapException {
  constructor(currentState, expectedStates) {
    super(currentState, expectedStates);
  }

  parse(currentState, expectedStates) {
    return `Expected ${currentState} to be one of ${expectedStates.join(', ')}`;
  }
}

function validStates(states) {
  return decorate(target, props, descriptor) {
    descriptor.value = wrap(descriptor.value, (fn, ...args)) {
      if (states.includes(this.state)) {
        throw new InvalidStateError(this.state, states);
      }
    }
  }
}

function invalidStates(states) {

}

function transmitError() [

]

// A note to the reader. This has been adapted from Linus's roap_session.cpp.
// Thanks to all the potential error conditions in a stateful, three-way
// handshaking  protocol like ROAP, that file is rather difficult to interpret
// (there are lots of switch statements; the unhappy paths make it difficult to
// find the  happy paths to wrap your head around how the protocol is intended
// to work).
//
// In an attempt to make this implemenation easier to understand, unhappy paths
// are encapselated in decorator functions, thus providing a clearer flow when
// things are working correctly.



/**
 * Adapted from the Linus ROAP Session. Manages state processing for the ROAP
 * messages associated with a given call.
 */
export default class RoapSession {
  static State = {
    INIT: 'INIT',
    INIT_WAIT_RX_OFFER: 'INIT_WAIT_RX_OFFER',
    INIT_WAIT_RX_ANSWER: 'INIT_WAIT_RX_ANSWER',
    WAIT_TX_OFFER: 'WAIT_TX_OFFER',
    WAIT_TX_ANSWER: 'WAIT_TX_ANSWER',
    WAIT_TX_OK: 'WAIT_TX_OK',
    WAIT_RX_OFFER: 'WAIT_RX_OFFER',
    WAIT_RX_ANSWER: 'WAIT_RX_ANSWER',
    WAIT_RX_ANSWER_RESPONSE: 'WAIT_RX_ANSWER_RESPONSE',
    WAIT_RX_OK: 'WAIT_RX_OK',
    IDLE_LOCAL_OFFER: 'IDLE_LOCAL_OFFER',
    IDLE_REMOTE_OFFER: 'IDLE_REMOTE_OFFER',
    ERROR: 'ERROR'
  }

  state = RoapSession.State.INIT;

  receive(msg) {

  }

  receiveAnswer(msg) {
    this.emit('answer')
  }

  @validStates([
    RoapSession.State.INIT,
    RoapSession.State.IDLE_LOCAL_OFFER,
    RoapSession.State.IDLE_REMOTE_OFFER,
    RoapSession.State.WAIT_RX_OK,
    RoapSession.State.WAIT_TX_OFFER
  ])
  transmitOffer(sdp) {
    if (!sdp) {
      throw new Error('Cannot transmit OFFER without SDP');
    }

    if (this.state !== RoapSession.State.WAIT_TX_OFFER) {
      this.startTransction();
    }

    let msg;
    switch (this.state) {
      case RoapSession.State.INIT:
        msg = new OfferMessage(this.seq, sdp);
        this.state = RoapSession.state.INIT_WAIT_RX_ANSWER;
        break;
      case RoapSession.WAIT_TX_OFFER:
        msg = new OfferResponseMessage(this.seq, sdp);
        this.state = RoapSession.state.WAIT_RX_ANSWER_RESPONSE;
        break;
      default:
        msg = new OfferMessage(this.seq, sdp);
        this.state = RoapSession.state.WAIT_RX_ANSWER;
        break;
    }


    return msg;
  }

  transmit(msg) {

  }
}
