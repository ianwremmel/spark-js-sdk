import {nonenumerable} from 'core-decorators';
/**
 * A ROAP message object
 */
export default class RoapMessage {
  messageType = '';

  seq = 0

  version = 2;

  // TODO move messageType and errorType enums here

  /**
   * constructor
   * @param {number} seq
   */
  constructor(options) {
    Object.defineProperty(this, 'session', {
      enumerable: false,
      writable: true
    });


    Object.assign(this, options);

    // Object.defineProperty(this, 'session', Object.assign({}, Object.getOwnPropertyDescriptor(this, 'session'), {
    //   enumerable: false,
    //   readOnly: false,
    //   readonly: false
    // }));
    if (!this.session) {
      this.session = options.session;
    }
  }

  /**
   * Generates a tie-breaker between 1 and 4294967295
   * @see https://tools.ietf.org/html/draft-jennings-rtcweb-signaling-01#section-5.4.1
   * @private
   * @returns {number}
   */
  static generateTieBreaker() {
    return Math.floor(1 + Math.random() * (0xFFFFFFFE - 1));
  }

  /* eslint-disable class-methods-use-this */
  /**
   * Indicates if this message is valid according to its
   * {@link RoapMessage#messageType}
   *
   * @returns {boolean}
   */
  isValid() {
    return false;
  }
  /* eslint-enable class-methods-use-this */

  /**
   * toString()
   * @see {@link Object#toString()}
   * @returns {string}
   */
  toString() {
    return `ROAP ${this.messageType} Message seq=${this.seq}`;
  }

  /**
   * Returns a promise that resolve when the RoapSession transitions to it's
   * next state. For example, for OfferMessages, `next()` will resolve when an
   * answer is received
   * @return {Promise}
   */
  next() {
    return Promise.reject(new Error('not implemented'));
  }
}
