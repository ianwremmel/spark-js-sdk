import Events from 'ampersand-events';
import {safeSetTimeout} from '@ciscospark/common-timers';

import fromObject, {
  AnswerMessage,
  ErrorMessage,
  OfferMessage,
  OfferRequestMessage,
  OfferResponseMessage,
  OkMessage,
  RoapMessage
} from './messages';

/**
 * Enumerates potential ErrorMessage subtypes
 * @readonly
 * @enum {string}
 */
const roapErrorType = {
  Conflict: 'CONFLICT',
  Failed: 'FAILED',
  InvalidState: '',
  OOO: 'OUT_OF_ORDER',
  Retry: 'RETRY',
  Refused: 'REFUSED',
  DoubleConflict: 'DOUBLE_CONFLICT'
};

/**
 * Enumerates potential ROAP session states
 * @readonly
 * @enum {string}
 */
export const roapState = {
  INIT: 'ROAP_STATE_INIT',
  INIT_WAIT_RX_OFFER: 'ROAP_STATE_INIT_WAIT_RX_OFFER',
  INIT_WAIT_RX_ANSWER: 'ROAP_STATE_INIT_WAIT_RX_ANSWER',
  WAIT_TX_OFFER: 'ROAP_STATE_WAIT_TX_OFFER',
  WAIT_TX_ANSWER: 'ROAP_STATE_WAIT_TX_ANSWER',
  WAIT_TX_OK: 'ROAP_STATE_WAIT_TX_OK',
  WAIT_RX_OFFER: 'ROAP_STATE_WAIT_RX_OFFER',
  WAIT_RX_ANSWER: 'ROAP_STATE_WAIT_RX_ANSWER',
  WAIT_RX_ANSWER_RESPONSE: 'ROAP_STATE_WAIT_RX_ANSWER_RESPONSE',
  WAIT_RX_OK: 'ROAP_STATE_WAIT_RX_OK',
  IDLE_LOCAL_OFFER: 'ROAP_STATE_IDLE_LOCAL_OFFER',
  IDLE_REMOTE_OFFER: 'ROAP_STATE_IDLE_REMOTE_OFFER',
  ERROR: 'ROAP_STATE_ERROR'
};

const initialStates = new Set([
  roapState.INIT,
  roapState.INIT_WAIT_RX_OFFER,
  roapState.INIT_WAIT_RX_ANSWER
]);

const remotePendingStates = new Set([
  roapState.INIT,
  roapState.WAIT_TX_OFFER,
  roapState.WAIT_TX_ANSWER,
  roapState.WAIT_TX_OK,
  roapState.IDLE_LOCAL_OFFER,
  roapState.IDLE_REMOTE_OFFER,
  roapState.ERROR
]);

/**
 * @event transmit
 */

/**
 * @event receiveOffer
 */

/**
 * @event receiveAnswer
 */

/**
 * @event receiveOk
 */

/**
 * @event receiveError
 */

/**
 * @event transactionTimeout
 */

const states = new WeakMap();

/**
 * Adapted from the Linus ROAP Session. Manages state processing for the ROAP
 * messages associated with a given call.
 */
export default class ROAPSession {
  /**
   * Confirms the speficied message is, in fact, a supported version
   * @param {RoapMessage} msg
   * @private
   * @returns {boolean}
   */
  static validateVersion(msg) {
    return msg.version === 2;
  }

  /**
   * @type {RoapMessage}
   */
  lastReceivedMessage;

  /**
   * @type {OfferMessage}
   */
  lastTransmitOffer

  /**
   * @type {OfferRequestMessage}
   */
  lastTransmitOfferRequest;

  /**
   * @type {AnswerMessage}
   */
  lastTransmitAnswer;

  /**
   * @type {OkMessage}
   */
  lastTransmitOk

  logger = console;

  receiveStats;

  retransmitDuration;

  retransmitTimer;

  seq = 0;

  /**
   * Indicates if the this RoapSession is suspended
   */
  suspended = false;

  transactionTimeoutDuration;

  transactionTimeoutTimer;

  transmitStats;

  /**
   * setter
   * @param {roapState} newState
   */
  set state(newState) {
    if (!(Object.values(roapState).includes(newState))) {
      throw new Error(`${newState} is not a valid roapState`);
    }
    states.set(this, newState);
  }

  /**
   * getter
   * @returns {roapState}
   */
  get state() {
    return states.get(this);
  }

  /**
   * constructor
   * @private
   * @param {Logger} logger
   */
  constructor(logger = console) {
    this.logger = logger;

    this.state = roapState.INIT;
  }

  /**
   * Indicates if we're partway throught a ROAP three-way handshake
   * @returns {boolean}
   */
  isTransactionInProgress() {
    switch (this.state) {
      case roapState.INIT:
      case roapState.IDLE_LOCAL_OFFER:
      case roapState.IDLE_REMOTE_OFFER:
      case roapState.ERROR:
        return false;

      case roapState.INIT_WAIT_RX_OFFER:
      case roapState.INIT_WAIT_RX_ANSWER:
      case roapState.WAIT_TX_OFFER:
      case roapState.WAIT_TX_ANSWER:
      case roapState.WAIT_TX_OK:
      case roapState.WAIT_RX_OFFER:
      case roapState.WAIT_RX_ANSWER:
      case roapState.WAIT_RX_ANSWER_RESPONSE:
      case roapState.WAIT_RX_OK:
        return true;

      default:
        throw new Error('Unreachable code reached');
    }
  }

  /**
   * Retransmits the last message for the current state
   * @private
   */
  processRetransmitTimer() {
    switch (this.state) {
      case roapState.INIT_WAIT_RX_OFFER:
      case roapState.WAIT_RX_OFFER:
        // timer popped and we are waiting on an offer from the remote
        // side.  our offer request may have been lost, so send it
        // again.
        this.transmitMessage(this.lastTransmitOfferRequest);
        break;

      case roapState.INIT_WAIT_RX_ANSWER:
      case roapState.WAIT_RX_ANSWER:
      case roapState.WAIT_RX_ANSWER_RESPONSE:
        // timer popped and we are waiting on an answer from the
        // remote side.  our offer may have been lost, so send it
        // again.
        this.transmitMessage(this.lastTransmitOffer);
        break;

      case roapState.WAIT_RX_OK:
        // timer popped and we are waiting on an ok from the remote
        // side.  our answer may have been lost, so send it again.
        this.transmitMessage(this.lastTransmitOk);
        break;

      default:
        // not expecting timers in the remaining states.  if the timer pops,
        // just ignore it.
        return;
    }

    // reschedule our timer
    this.scheduleRetransmitTimer();
  }

  /**
   * Signals we've waited long enough and the transaction should be aborted.
   * @private
   */
  processTransactionTimeoutTimer() {
    if (remotePendingStates.has(this.state)) {
      // timer popped and we are still waiting on some message from remote side
      // time to give up and fire a timeout callback.
      this.emit('transactionTimeout');
    }
  }

  /**
   * Receives a ROAP message over the wire and reacts to it accordingly
   * @param {RoapMessage|Object} raw
   * @returns {undefined}
   */
  receive(raw) {
    const msg = raw instanceof RoapMessage ? raw : fromObject(raw);

    if (!msg.isValid) {
      this.logger.info('received invalid ROAP message', msg);
      return;
    }

    if (!ROAPSession.validateVersion(msg)) {
      const errorMessage = `unexpected version '${msg.version}' expected '2'`;
      this.transmitErrorMessage(msg, roapErrorType.Refused, errorMessage);
      return;
    }

    if (!initialStates.has(this.state)) {
      if (msg.seq < this.seq) {
        this.transmitOOOErrorMessage(msg, false);
      }
    }

    this.lastReceivedMessage = msg;

    if (msg instanceof AnswerMessage) {
      this.receiveAnswer(msg);
    }
    else if (msg instanceof ErrorMessage) {
      this.receiveError(msg);
    }
    else if (msg instanceof OfferMessage) {
      this.receiveOffer(msg);
    }
    else if (msg instanceof OfferRequestMessage) {
      this.receiveOfferRequest(msg);
    }
    else if (msg instanceof OfferResponseMessage) {
      this.receiveOfferResponse(msg);
    }
    else if (msg instanceof OkMessage) {
      this.receiveOk(msg);
    }
  }

  /**
   * Handles incomine Answer ROAP messages
   * @private
   * @param {AnswerMessage} msg
   */
  receiveAnswer(msg) {
    switch (this.state) {
      case roapState.INIT_WAIT_RX_ANSWER:
        // received answer must have the same sequence number as what we are
        // expecting.  this is the first message we have received from the
        // remote side so remember the remote session id.
        if (msg.seq !== this.seq) {
          this.transmitOOOErrorMessage(msg, false);
        }
        break;
      case roapState.WAIT_TX_OK:
        // received an answer while waiting to send an OK.  if this is a
        // retransmission then ignore it.  otherwise send an invalid state
        // error.
        if (msg.seq !== this.seq) {
          return;
        }

        this.transmitInvalidStateErrorMessage(msg);
        return;

      case roapState.WAIT_RX_ANSWER_RESPONSE: /* falls through */
      case roapState.WAIT_RX_ANSWER:
        // received answer must have the same sequence number as what we are
        // expecting
        if (msg.seq !== this.seq) {
          this.transmitOOOErrorMessage(msg, false);
          return;
        }
        break;

      case roapState.IDLE_LOCAL_OFFER:
        // this could be a re-transmission of a previous answer trying to get an
        // OK msg. retransmit ok only if we sent an ok previously otherwise
        // let the answer proceed
        if (msg.seq === this.seq && this.lastTransmitOk) {
          this.transmitMessage(this.lastTransmitOk);
          return;
        }
        break;

      default:
        this.transmitInvalidStateErrorMessage(msg);
    }

    this.state = roapState.WAIT_TX_OK;
    this.emit('receiveAnswer', msg.sdps);
  }

  /**
   * Helper method for handling an incoming error message
   * @param {ErrorMessage} msg
   * @private
   */
  receiveError(msg) {
    switch (this.state) {
      case roapState.ERROR:
        // already in error state, can't really be more errored
        return;

      case roapState.INIT_WAIT_RX_OFFER: /* falls through */
      case roapState.INIT_WAIT_RX_ANSWER:
        // make sure sequence number is correct.  if it is then fall
        // through.  if it is not then just ignore the error.
        if (msg.seq < this.seq) {
          return;
        }
        break;

      case roapState.WAIT_RX_OFFER:
        // make sure sequence number is correct.  if it is not then
        // just ignore the error.
        if (msg.seq < this.seq) {
          return;
        }

        if (msg.errorType === roapErrorType.Retry) {
          // we sent an offer request, received a retry error.
          // trigger a new offer request.
          this.state = roapState.IDLE_LOCAL_OFFER;
          this.transmitOfferRequest();
          return;
        }
        break;

      case roapState.WAIT_RX_ANSWER:
        // make sure sequence number is correct.  if it is not then
        // just ignore the error.
        if (msg.seq < this.seq) {
          return;
        }

        if (msg.errorType === roapErrorType.Retry) {
          // we sent an offer, received a retry error.  trigger a
          // new offer.
          this.state = roapState.IDLE_LOCAL_OFFER;
          this.transmitOffer(this.lastTransmitOffer.sdps);
          return;
        } if (msg.errorType === roapErrorType.Conflict) {
          // we lost a glare condition at some point, ignore this error
          return;
        }
        break;

      case roapState.WAIT_RX_OK:
        // make sure sequence number is correct.  if it is then fall
        // through.  if it is not then just ignore the error.
        if (msg.seq < this.seq) {
          return;
        }

        // if the error cause was conflict, then ignore the error message
        if (msg.errorType === roapErrorType.Conflict) {
          return;
        }
        break;

      default:
        // invalid state to receive this message in, just ignore it
        return;
    }

    // error message was received, tell the user.  not really possible
    // to recover from this, so move into error state and invoke callback.
    this.state = roapState.ERROR;

    this.emit('receiveError');
  }

  /**
   * Helper method for handling an incoming offer message
   * @param {OfferMessage} msg
   * @private
   */
  receiveOffer(msg) {
    switch (this.state) {
      case roapState.INIT:
        // received an offer while in init state, this is the first
        // thing we have received so it is valid.
        break;

      case roapState.INIT_WAIT_RX_OFFER:
        // received an offer while waiting to receive the first
        // message from the remote side.  make sure the sequence
        // number is correct
        if (msg.seq < this.seq) {
          this.transmitOOOErrorMessage(msg, false);
          return;
        }
        break;

      case roapState.WAIT_TX_ANSWER:
        // received a remote offer while waiting to send an answer.
        // if this is a retransmission then ignore it, otherwise
        // process normally.
        if (msg.seq === this.seq) {
          // retransmission, ignore
          return;
        }
        break;

      case roapState.WAIT_RX_OK:
        // received a remote offer while waiting for an ok.  if this
        // is a retransmission then send our last answer again,
        // otherwise process normally.  this might happen if the
        // remote side received our answer but did not send an ok (or
        // the ok got lost).
        if (msg.seq === this.seq) {
          // retransmission, retransmit last answer
          this.transmitMessage(this.lastTransmitAnswer);
          return;
        }
        // this is a new offer, the ok may have been lost.  fake
        // reception of the OK, then fall through to process the
        // new offer.
        this.emit('receiveOk');

        break;
      case roapState.WAIT_TX_OK:
        // received a remote offer while waiting to send an ok.
        // if this is not a new request, then return an error. if
        // this is a new request, then assume the other side don't want the ok
        // then fall through to process the new offer.
        if (msg.seq === this.seq) {
          this.transmitInvalidStateErrorMessage(msg);
          return;
        }
        // if we get to here, this is a new offer. assuming the other
        // side doesn't want the ok; just proceed with this new offer.
        break;

      case roapState.WAIT_RX_OFFER:
        // received a remote offer while waiting for an offer.  check
        // that the sequence number is the expected sequence number.
        if (msg.seq < this.seq) {
          this.transmitOOOErrorMessage(msg, false);
          return;
        }
        break;

      case roapState.INIT_WAIT_RX_ANSWER:
      case roapState.WAIT_RX_ANSWER:
        // received a remote offer while we have a pending offer.
        // this may be a GLARE condition.  if the sequence number is
        // older than our current sequence number then just send an
        // error back.  if the sequence number is the same as our
        // sequence number, then we have GLARE.  if the sequence
        // number is newer, then perhaps the answer was lost and this
        // is a new transaction.
        if (msg.seq < this.seq) {
          // ooo case.
          this.transmitOOOErrorMessage(msg, false);
          return;
        } if (msg.seq === this.seq) {
          if (!msg.tieBreaker) {
            // no tie-breaker, this is an error
            this.transmitErrorMessage(msg, roapErrorType.Failed, 'missing tieBreaker field');
            return;
          }

          // glare case.  compare the tie-breaker is our last offer
          // with the tie-breaker in this offer, the higher value
          // wins.
          if (msg.tieBreaker < this.lastTransmitOffer.tieBreaker) {
            // we win, send an error and stop processing this offer
            // ROAP_LOG('glare but we win');
            this.transmitConflictErrorMessage(msg, this.lastTransmitOffer);
            return;
          } if (msg.tieBreaker === this.lastTransmitOffer.tieBreaker) {
            // both sides lose, send an error, retransmit our
            // offer with a new tie breaker.
            // ROAP_LOG('glare everyone loses');
            this.transmitDoubleConflictErrorMessage(msg, this.lastTransmitOffer);

            this.state = roapState.IDLE_LOCAL_OFFER;
            this.transmitOffer(this.lastTransmitOffer.sdps);
            return;
          }
          // we lose, process this offer
          // ROAP_LOG('glare we lose');
        }
        else {
          // new transaction, we never got the answer we wanted but
          // let's just pretend like that didn't happen.  the new
          // offer's data is more recent than the expected answer
          // anyways.
          // ROAP_LOG('glare we lose, remote has higher seqnum');
        }
        break;

      case roapState.WAIT_RX_ANSWER_RESPONSE:
      case roapState.WAIT_TX_OFFER:
      case roapState.ERROR:
        // invalid state to receive this message in
        this.transmitInvalidStateErrorMessage(msg);
        return;

      case roapState.IDLE_LOCAL_OFFER:
      case roapState.IDLE_REMOTE_OFFER:
        // received an offer while in idle state, the sequence number
        // must increment.
        if (msg.seq === this.seq) {
          this.transmitOOOErrorMessage(msg, true);
          return;
        }
        break;

      default:
        throw new Error('should be unreachable');
    }

    // a valid offer has been received.  remember the sequence number,
    // change state, and fire the callback
    this.seq = msg.seq;
    this.state = roapState.WAIT_TX_ANSWER;

    // this is a new transaction, start transaction timeout timer too
    this.startNewTransaction(false);

    this.emit('receiveOffer', msg.sdps);
  }

  /**
   * Helper method for handling an incoming offer request message
   * @param {OfferRequestMessage} msg
   * @private
   */
  receiveOfferRequest(msg) {
    switch (this.state) {
      case roapState.INIT:
        // received an offer request while in init state, this is the
        // first thing we have received so it is valid.
        break;

      case roapState.WAIT_TX_OFFER:
        // received an offer request while waiting to send an offer.
        // if the sequence number is the same as the last received
        // offer request then this is a retransmission, ignore it.  if
        // the sequence number is higher, then this is a new event.
        if (msg.seq === this.seq) {
          return;
        }
        break;

      case roapState.IDLE_LOCAL_OFFER:
      case roapState.IDLE_REMOTE_OFFER:
        // received an offer request while in idle state, the sequence
        // number must increment.
        if (msg.seq === this.seq) {
          this.transmitOOOErrorMessage(msg, true);
          return;
        }
        break;

      case roapState.INIT_WAIT_RX_OFFER:
      case roapState.WAIT_RX_OFFER:
        // received an offer request while we have a pending offer
        // request.  this may be a GLARE condition.  if the sequence
        // number is older than our current sequence number then just
        // send an error back.  if the sequence number is the same as
        // our sequence number, then we have GLARE.  if the sequence
        // number is newer, then perhaps the offer was lost and this
        // is a new transaction.
        if (msg.seq < this.seq) {
          // ooo case.
          this.transmitOOOErrorMessage(msg, false);
          return;
        } if (msg.seq === this.seq) {
          if (!msg.tieBreaker) {
            // no tie-breaker, this is an error
            this.transmitErrorMessage(msg, roapErrorType.Failed, 'missing tieBreaker field');
            return;
          }

          // glare case.  compare the tie-breaker in our last offer
          // request with the tie-breaker in this offer request, the
          // higher value wins.
          if (msg.tieBreaker < this.lastTransmitOfferRequest.tieBreaker) {
            // we win, send an error and stop processing this offer
            this.transmitConflictErrorMessage(msg, this.lastTransmitOfferRequest);
            return;
          } if (msg.tieBreaker === this.lastTransmitOfferRequest.tieBreaker) {
            // both sides lose, send an error, retransmit our
            // offer request with a new tie breaker.
            // ROAP_LOG('glare everyone loses');
            this.transmitDoubleConflictErrorMessage(msg, this.lastTransmitOfferRequest);

            this.state = roapState.IDLE_LOCAL_OFFER;
            this.transmitOfferRequest();
            return;
          }
          // we lose, process this offer request
          // ROAP_LOG('glare we lose');
        }
        else {
          // new transaction, we never got the offer we wanted but
          // let's just pretend like that didn't happen.
          // ROAP_LOG('glare we lose, remote has higher seqnum');
        }
        break;

      case roapState.INIT_WAIT_RX_ANSWER:
      case roapState.WAIT_RX_ANSWER:
        // received an offer request while we have a pending offer.
        // this may be a GLARE condition.  if the sequence number is
        // older then just send an error back.
        if (msg.seq < this.seq) {
          // ooo case.
          this.transmitOOOErrorMessage(msg, false);
          return;
        }

        if (msg.seq === this.seq) {
          if (!msg.tieBreaker) {
            // no tie-breaker, this is an error
            this.transmitErrorMessage(msg, roapErrorType.Failed, 'missing tieBreaker field');
            return;
          }

          // glare case.  compare the tie-breaker in our last offer
          // with the tie-breaker in this offer request, the higher
          // value wins.
          if (msg.tieBreaker < this.lastTransmitOffer.tieBreaker) {
            // we win, send an error and stop processing this offer request
            this.transmitConflictErrorMessage(msg, this.lastTransmitOffer);
            return;
          } if (msg.tieBreaker === this.lastTransmitOffer.tieBreaker) {
            // both sides lose, send an error, retransmit our
            // offer with a new tie breaker.
            // ROAP_LOG('glare everyone loses');
            this.transmitDoubleConflictErrorMessage(msg, this.lastTransmitOffer);

            this.state = roapState.IDLE_LOCAL_OFFER;
            this.transmitOffer(this.lastTransmitOffer.sdps);
            return;
          }
          // we lose, process this offer request
          // ROAP_LOG('glare we lose');
        }
        else {
          // new transaction, we never got the offer we wanted but
          // let's just pretend like that didn't happen.
          // ROAP_LOG('glare we lose, remote has higher seqnum');
        }
        break;

      case roapState.WAIT_RX_OK:
        // received a remote offer request while waiting for an ok.
        // if this is not a new request, then return an error.  if
        // this is a new request, then assume the ok was lost (trigger
        // a fake callback), then fall through to process the new
        // offer request.
        if (msg.seq === this.seq) {
          this.transmitInvalidStateErrorMessage(msg);
          return;
        }
        this.trigger('receiveOk', msg);

        break;
      case roapState.WAIT_TX_OK:
        // received a remote offer request while waiting to send an ok.
        // if this is not a new request, then return an error. if
        // this is a new request, then assume the other side don't want the ok
        // then fall through to process the new offer request.
        if (msg.seq === this.seq) {
          this.transmitInvalidStateErrorMessage(msg);
          return;
        }
        // if we get to here, this is a new offer request. assuming the other
        // side doesn't want the ok; just proceed with this new offer request.
        break;

      case roapState.WAIT_RX_ANSWER_RESPONSE:
      case roapState.WAIT_TX_ANSWER:
      case roapState.ERROR:
        // invalid state to receive this message in
        this.transmitInvalidStateErrorMessage(msg);
        return;
      default:
        throw new Error('should be unreachable');
    }

    // a valid offer request has been received.  remember the sequence
    // number, change state, and fire the callback
    this.seq = msg.seq;
    this.state = roapState.WAIT_TX_OFFER;

    // this is a new transaction
    this.startNewTransaction(false);

    this.emit('receiveOfferRequest');
  }

  /**
   * Helper method for handling an incoming offer response message
   * @param {OfferResponseMessage} msg
   * @private
   */
  receiveOfferResponse(msg) {
    switch (this.state) {
      case roapState.INIT_WAIT_RX_OFFER:
      case roapState.WAIT_RX_OFFER:
        // received a remote offer while waiting for an offer.  check
        // that the sequence number is the expected sequence number.
        if (msg.seq < this.seq) {
          this.transmitOOOErrorMessage(msg, false);
          return;
        }
        break;

      case roapState.WAIT_TX_ANSWER:
        // received a remote offer response while waiting to send an
        // answer.  if this is a retransmission then ignore it,
        // otherwise process normally.
        if (msg.seq === this.seq) {
          // retransmission, ignore
          return;
        }
        break;

      case roapState.WAIT_RX_OK:
        // received a remote offer response while waiting for an ok.
        // if this is a retransmission then send our last answer
        // again, otherwise process normally.  this might happen if
        // the remote side did not receive our answer.
        if (msg.seq === this.seq) {
          // retransmission, retransmit last answer
          this.transmitMessage(this.lastTransmitAnswer);
          return;
        }
        break;

      default:
        // invalid state to receive this message in
        this.transmitInvalidStateErrorMessage(msg);
        return;
    }

    // a valid offer has been received.  remember the sequence number,
    // change state, and fire the callback
    this.seq = msg.seq;
    this.state = roapState.WAIT_TX_ANSWER;

    this.emit('receiveOffer', msg.sdps);
  }

  /**
   * Helper method for handling an incoming ok message
   * @param {OkMessage} msg
   * @private
   */
  receiveOk(msg) {
    switch (this.state) {
      case roapState.WAIT_RX_OK:
        // make sure sequence number is correct.  if it is then fall
        // through.
        if (msg.seq < this.seq) {
          this.transmitOOOErrorMessage(msg, false);
          return;
        }
        break;

      case roapState.IDLE_REMOTE_OFFER:
        // could just be a retransmission, if sequence number is
        // valid then just ignore it
        if (msg.seq <= this.seq) {
          return;
        }
        break;

      default:
        // invalid state to receive this message in
        this.transmitInvalidStateErrorMessage(msg);
        return;
    }

    // valid ok received, change state and invoke callback
    this.state = roapState.IDLE_REMOTE_OFFER;

    this.emit('receiveOk');
  }

  /**
   * Helper. Sets a timer
   * @private
   */
  scheduleRetransmitTimer() {
    clearTimeout(this.retransmitTimer);
    this.retransmitTimer = safeSetTimeout(() => this.processRetransmitTimer(), this.retransmitDuration);
  }

  /**
   * Helper. Sets a timer
   * @private
   */
  scheduleTransactionTimeoutTimer() {
    clearTimeout(this.transactionTimeoutTimer);
    this.transactionTimeoutTimer = safeSetTimeout(() => this.processTransactionTimeoutTimer());
  }

  /**
   * Sets a new transaction
   * @param {boolean} isLocal
   * @private
   */
  startNewTransaction(isLocal) {
    if (isLocal) {
      this.seq += 1;
    }

    this.scheduleRetransmitTimer();
    this.scheduleRetransmitTimer();
  }

  /**
   * Transmit an answer to the remote peer
   * @param {Array<string>} sdps
   */
  transmitAnswer(sdps = []) {
    if (!sdps.length) {
      throw new Error('sdps cannot be empty');
    }

    if (this.state !== roapState.WAIT_TX_ANSWER) {
      throw new Error(`Cannot transmit ANSWER unless in ${roapState.WAIT_TX_ANSWER} state`);
    }

    this.lastTransmitAnswer = new AnswerMessage(this.seq, sdps);
    this.transmitMessage(this.lastTransmitAnswer);
    this.state = roapState.WAIT_RX_OK;
  }

  /**
   * Helper method. Transmit a conflict error to the remote peer
   * @param {RoapMessage} msg - incoming message
   * @param {RoapMessage} last - last sent message
   * @private
   */
  transmitConflictErrorMessage(msg, last) {
    const errorMessage = `detected winning glare condition remoteTieBreaker=${msg.tieBreaker} localTieBreaker=${last.tieBreaker}`;
    this.transmitErrorMessage(msg, roapErrorType.Conflict, errorMessage);
  }

  /**
   * Helper method. Transmit a double conflict error to the remote peer
   * @param {RoapMessage} msg - incoming message
   * @param {RoapMessage} last - last sent message
   * @private
   */
  transmitDoubleConflictErrorMessage(msg, last) {
    const errorMessage = `detected tying glare condition remoteTieBreaker=${msg.tieBreaker
    } localTieBreaker=${last.tieBreaker}`;
    this.transmitErrorMessage(msg, roapErrorType.DoubleConflict, errorMessage);
  }

  /**
   * Transmit aan error to the remote peer
   * @param {string} errorCause
   */
  transmitError(errorCause) {
    switch (this.state) {
      case roapState.WAIT_TX_OFFER:
        {
          const msg = new ErrorMessage(this.seq, roapErrorType.Failed, errorCause);

          this.transmitMessage(msg);

          // change state back to idle, the current transaction is done
          this.state = roapState.IDLE_LOCAL_OFFER;
        }
        break;

      case roapState.WAIT_TX_ANSWER:
        {
          const msg = new ErrorMessage(this.seq, roapErrorType.Failed, errorCause);

          this.transmitMessage(msg);

          // change state back to idle, the current transaction is done
          this.state = roapState.IDLE_REMOTE_OFFER;
        }
        break;

      case roapState.WAIT_TX_OK:
        {
          const msg = new ErrorMessage(this.seq, roapErrorType.Failed, errorCause);

          this.transmitMessage(msg);

          // change state back to idle, the current transaction is done
          this.state = roapState.IDLE_LOCAL_OFFER;
        }
        break;
      default:
        throw new Error('Invalid state');
    }
  }

  /**
   * Helper method. Transmit an error message to the remote peero
   * @param {RoapMessage} msg
   * @param {roapErrorType} errorType
   * @param {string} errorCause
   * @private
   */
  transmitErrorMessage(msg, errorType, errorCause) {
    const error = new ErrorMessage(msg.seq, errorType, errorCause);
    this.transmitMessage(msg, error);
  }

  /**
   * Helper method. Transmit a conflict error to the remote peer
   * @param {RoapMessage} msg - incoming message
   * @private
   */
  transmitInvalidStateErrorMessage(msg) {
    const errorMessage = `received invalid message type '${msg.messageType}' in state '${this.state}'`;
    this.transmitErrorMessage(msg, roapErrorType.InvalidState, errorMessage);
  }

  /**
   * Triggers the transmit callback
   * @param {RoapMessage} msg
   * @private
   */
  transmitMessage(msg) {
    this.emit('transmit', msg);
  }

  /**
   * Helper method. Transmit an out-of-order error to the remote peer
   * @param {RoapMessage} msg
   * @param {bool} expectedNew
   * @private
   */
  transmitOOOErrorMessage(msg, expectedNew) {
    const expectedSeq = (expectedNew ? (this.seq + 1) : this.seq);
    // don't response to ooo with ooo
    if (msg instanceof ErrorMessage && msg.errorType && msg.errorType === roapErrorType.OOO) {
      // ROAP_LOG(`ignoring ooo message\n${source}`);
    }
    else {
      const errorMessage = `received seq ${msg.seq} expected at least ${expectedSeq}`;
      this.transmitErrorMessage(msg, roapErrorType.OOO, errorMessage);
    }
  }

  /**
   * Transmit an offer to the remote peer
   * @param {Array<string>} sdps
   */
  transmitOffer(sdps = []) {
    // SDPs must not be empty
    if (!sdps.length) {
      throw new Error('sdps cannot be empty');
    }

    switch (this.state) {
      case roapState.INIT:
      case roapState.IDLE_LOCAL_OFFER:
      case roapState.IDLE_REMOTE_OFFER:
      case roapState.WAIT_RX_OK:
      // valid to send an offer in these states.  this will be a new
      // transaction;
      //
      // for roapState.WAIT_RX_OK, allow transmit of new remote offer
      // while waiting to receive an ok from previous offer
        this.startNewTransaction(true);
        break;

      case roapState.WAIT_TX_OFFER:
      // valid to send an offer in this state.  this will be in
      // response to an offer request so we do not bump the sequence
      // number.
        break;

      default:
        throw new Error(`ignoring offer transmit due to current state ${this.state} is not a valid state to transmit offer`);
    }

    if (this.state === roapState.INIT) {
      // create the initial offer message to be sent. the remote session id (answerer
      // session id) is not known.
      this.lastTransmitOffer = new OfferMessage(this.seq, sdps);

      // send out the offer
      this.transmitMessage(this.lastTransmitOffer);

      // change state
      this.state = roapState.INIT_WAIT_RX_ANSWER;
    }
    else {
      let newState = roapState.WAIT_RX_ANSWER;
      if (this.state === roapState.WAIT_TX_OFFER) {
        // after version 1 we use the offer response message to
        // respond to an offer request
        this.lastTransmitOffer = new OfferResponseMessage(this.seq, sdps);
        newState = roapState.WAIT_RX_ANSWER_RESPONSE;
      }
      else {
        // create the non-initial offer message to be sent.  when we
        // are transmitting an offer, the local session id is the
        // offerer and the remote session id is the answerer
        this.lastTransmitOffer = new OfferMessage(this.seq, sdps);
      }

      // send out the offer
      this.transmitMessage(this.lastTransmitOffer);

      this.state = newState;
    }
  }

  /**
   * Transmit an offer request to the remote peer
   */
  transmitOfferRequest() {
    switch (this.state) {
      case roapState.INIT:
      case roapState.IDLE_LOCAL_OFFER:
      case roapState.IDLE_REMOTE_OFFER:
      case roapState.WAIT_RX_OK:
        // valid to send an offer request in these states.  this will
        // be a new transaction.
        //
        // for roapState.WAIT_RX_OK, allow transmit of new remote offer request
        // while waiting to receive an ok from previous request
        this.startNewTransaction(true);
        break;

      default:
        throw new Error('Invalid state for processing an OFFER_REQUEST');
    }

    if (this.state === roapState.INIT) {
      // create the initial offer request message to be sent.
      // the remote session id (offerer session id) is not known.
      this.lastTransmitOfferRequest = new OfferRequestMessage(this.seq);

      // send out the offer
      this.transmitMessage(this.lastTransmitOfferRequest);

      // change state
      this.state = roapState.INIT_WAIT_RX_OFFER;
    }
    else {
      // create the non-initial offer request message to be sent.
      // when we are transmitting an offer request, the local
      // session id is the answerer and the remote session id is the
      // offerer
      this.lastTransmitOfferRequest = new OfferRequestMessage(this.seq);

      // send out the offer
      this.transmitMessage(this.lastTransmitOfferRequest);

      this.state = roapState.WAIT_RX_OFFER;
    }
  }

  /**
   * Transmit an OK message to the remote peer
   */
  transmitOk() {
    if (this.state !== roapState.WAIT_TX_OK) {
      throw new Error(`Cannot transmit OK unless in ${roapState.WAIT_TX_OK} state`);
    }

    this.lastTransmitOk = new OkMessage(this.seq);

    // send out the ok
    this.transmitMessage(this.lastTransmitOk);

    this.state = roapState.IDLE_LOCAL_OFFER;
  }
}

Object.assign(ROAPSession.prototype, Events);

