import {assert} from '@ciscospark/test-helper-chai';

export function assertLocalKind(kind, direction, adapter) {
  const tracks = adapter.localMediaStream.getTracks().filter((t) => t.kind === kind);
  if (direction.includes(`send`)) {
    assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
    // assert.lengthOf(adapter.pc.getSenders().filter((s) => s.track.kind === kind), 1, `local ` + kind + `is ` + direction);
    assert.isTrue(tracks[0].enabled, `the local ${kind} track is enabled`);
    // assert.isTrue(adapter.pc.getSenders().find((s) => s.track.kind === kind).track.enabled. `local ` + kind + `is ` + direction);
  }
  else {
    try {
      assert.lengthOf(tracks, 0, `there are 0 local ${kind} tracks`);
      // assert.lengthOf(adapter.pc.getSenders().filter((s) => s.track.kind === kind), 0, `local ` + kind + `is ` + direction);
    }
    catch (err) {
      assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
      assert.isFalse(tracks[0].enabled, `the local ${kind} track is not enabled`);
      // assert.isFalse(adapter.pc.getSenders().find((s) => s.track.kind === kind).track.enabled, `local ` + kind + `is ` + direction);
    }
  }
}

export function assertRemoteKind(kind, direction, adapter) {
  const tracks = adapter.remoteMediaStream.getTracks().filter((t) => t.kind === kind);
  if (direction.includes(`recv`)) {

    assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
    // assert.lengthOf(adapter.pc.getRemoteStreams()[0].getTracks().filter((t) => t.kind === kind), 1, `local ` + kind + `is ` + direction);
    assert.isTrue(tracks[0].enabled, `the remote ${kind} track is enabled`);
    // assert.isTrue(adapter.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled, `local ` + kind + `is ` + direction);
  }
  else {
    if (adapter.remoteMediaStream) {
      try {
        assert.lengthOf(tracks, 0, `there are 0 remote ${kind} tracks`);
      }
      catch (err) {
        assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
        assert.isFalse(tracks[0].enabled, `the remote ${kind} track is not enabled`);
      }
    }

    if (adapter.pc.getRemoteStreams()[0]) {
      try {
        assert.lengthOf(adapter.pc.getRemoteStreams()[0].getTracks().filter((t) => t.kind === kind), 0, `remote ${kind} is ${direction}`);
      }
      catch (err) {
        assert.isFalse(adapter.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled, `remote ${kind} is ${direction}`);
      }
    }
  }
}

export function assertLocalMedia(adapter, targetAudioDirection, targetVideoDirection) {
  assertLocalKind(`audio`, targetAudioDirection, adapter);
  assertLocalKind(`video`, targetVideoDirection, adapter);
}

export function assertRemoteMedia(adapter, targetAudioDirection, targetVideoDirection) {
  assertRemoteKind(`audio`, targetAudioDirection, adapter);
  assertRemoteKind(`video`, targetVideoDirection, adapter);
}
