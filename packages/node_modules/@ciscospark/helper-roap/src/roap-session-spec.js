import _ from 'lodash';
import {assert} from '@ciscospark/test-helper-chai';

import fromObject, {
  AnswerMessage,
  ErrorMessage,
  OfferMessage,
  OfferRequestMessage,
  OfferResponseMessage,
  OkMessage
} from './messages';
import ROAPSession, {roapErrorType, roapState} from './roap-session';

describe('ROAPSession', () => {
  let
    receiveAnswerSdps,
    receiveErrorCount,
    receiveOfferRequestCount,
    receiveOfferSdps,
    receiveOkCount,
    rs,
    timeoutCount,
    transmitMessages;

  beforeEach(() => {
    rs = new ROAPSession();

    receiveAnswerSdps = [];
    receiveOfferRequestCount = 0;
    receiveOfferSdps = [];
    receiveOkCount = 0;
    receiveErrorCount = 0;
    timeoutCount = 0;
    transmitMessages = [];

    rs.on('transmit', (rm) => {
      transmitMessages.push(rm);
    });
    rs.on('receiveOfferRequest', () => {
      receiveOfferRequestCount += 1;
    });
    rs.on('receiveOffer', (sdps) => receiveOfferSdps.push(sdps));
    rs.on('receiveAnswer', (sdps) => receiveAnswerSdps.push(sdps));
    rs.on('receiveOk', () => {
      receiveOkCount += 1;
    });
    rs.on('receiveError', () => {
      receiveErrorCount += 1;
    });
    rs.on('transactionTimeout', () => {
      timeoutCount += 1;
    });
  });

  function doInitialReceiveOfferRequestFlow(sendOk = true) {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage());

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
    assert.isTrue(rs.isTransactionInProgress());

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, true);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert.isTrue(rs.isTransactionInProgress());

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.equal(receiveAnswerSdps.size(), 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert.isTrue(rs.isTransactionInProgress());

    if (sendOk) {
      // trigger transmission of an ok
      assert.doesNotThrow(() => rs.transmitOk());

      // should invoke the transmit callback with an ok message
      assert.equal(transmitMessages.length, 2);
      validateOkMessage(_.last(transmitMessages), 1);

      // state should be correct
      assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    }

    assert.notEqual(rs.isTransactionInProgress(), sendOk);
  }

  function validateOfferRequestMessage(rm, seq) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, OfferRequestMessage);
    assert.equal(seq, rm.seq);
  }

  function validateOfferMessage(rm, seq, sdps) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, OfferMessage);
    assert.equal(seq, rm.seq);

    assert.isDefined(rm.sdps);
    assert.equal(sdps, rm.sdps);
  }

  function validateOfferResponseMessage(rm, seq, sdps) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, OfferResponseMessage);
    assert.equal(seq, rm.seq);

    assert.isDefined(rm.sdps);
    assert.equal(sdps, rm.sdps);
  }

  function validateAnswerMessage(rm, seq, sdps) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, AnswerMessage);
    assert.equal(seq, rm.seq);

    assert.isDefined(rm.sdps);
    assert.equal(sdps, rm.sdps);
  }

  function validateOkMessage(rm,
    seq) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, OkMessage);
    assert.equal(seq, rm.seq);
  }

  function validateErrorMessage(rm, seq, errorType) {
    assert.isTrue(rm.isValid());
    assert.instanceOf(rm, ErrorMessage);
    assert.equal(seq, rm.seq);

    assert.equal(errorType, rm.errorType);
  }

  function doReceiveSubsequentOfferRequestFlow() {
    // trigger receive of an offer request
    rs.receive(new OfferRequestMessage(2, 0));

    // should have invoked callback that an offer request was received
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  function doReceiveSubsequentOfferFlow() {
    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(2, sdps, 0));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 2, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  function doTransmitSubsequentOffer() {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 2, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 2);
    validateOkMessage(_.last(transmitMessages), 2);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  function doTransmitSubsequentOfferRequest() {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 2);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(_.last(transmitMessages).seq, sdps, 0));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 2, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  function doReceiveOutOfOrderSubsequentOfferRequest() {
    // the original state
    const origState = rs.state;

    // trigger receive of an ooo offer request
    rs.receive(new OfferRequestMessage(1, 0));

    // should NOT have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // state should NOT have changed
    assert.equal(origState, rs.state);

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.OOO);
  }

  function doReceiveOutOfOrderSubsequentOffer() {
    // the original state
    const origState = rs.state;

    // trigger receive of an ooo offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(1, sdps, 0));

    // should NOT have invoked callback that an offer was received
    assert.lengthOf(receiveOfferSdps, 0);

    // state should NOT have changed
    assert.equal(origState, rs.state);

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.OOO);
  }

  it('passes the translated DefaultState test', () => {
    assert.equal(rs.state, roapState.INIT);
    assert.isFalse(rs.isTransactionInProgress());
  });

  function testInitialReceiveOfferRequestFlow() {
    doInitialReceiveOfferRequestFlow();
  }
  it('passes the translated InitialReceiveOfferRequestFlow test', () => {
    testInitialReceiveOfferRequestFlow();
  });

  it('passes the translated InitialReceiveOfferRequestFlowVersionTwo test', () => {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage());

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer response message
    assert.lengthOf(transmitMessages, 1);
    validateOfferResponseMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER_RESPONSE);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 2);
    validateOkMessage(_.last(transmitMessages), 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  });

  it('passes the translated InitialReceiveOfferRequestFlowVersionThree test', () => {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage(10, 0));

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 10, sdps, true);

    // state should be correctj
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // resend offer message
    rs.receive(new OfferRequestMessage(8, 0));

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // should invoke the transmit callback with out of bandwidth (OOO) message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 8, roapErrorType.OOO);
  });


  function testInitialReceiveOfferFlow() {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(1, sdps));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  it('passes the translated InitialReceiveOfferFlow test', () => {
    testInitialReceiveOfferFlow();
  });

  function testInitialReceiveOfferFlowVersionTwo() {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps, undefined));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  it('passes the translated InitialReceiveOfferFlowVersionTwo test', () => {
    testInitialReceiveOfferFlowVersionTwo();
  });

  it('passes the translated InitialReceiveOfferFlowDuplicateOk test', () => {
    // set things up
    testInitialReceiveOfferFlow();

    // remember this
    const preSize = transmitMessages.length;

    // send in another (duplicate) ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should not send out an error message (or any other message)
    assert.equal(preSize, transmitMessages.length);
  });

  it('passes the translated InitialReceiveBadOffer test', () => {
    // trigger receive of an initial offer request with a bad Version
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(sdps);
    // Intentionally insert bad version in message
    offerMessage.version = '0';
    rs.receive(offerMessage);

    // Since there was a bad message version, should NOT have invoked
    // callback to process received offer.
    assert.lengthOf(receiveOfferSdps, 0);
  });

  function testInitialTransmitOfferRequestFlow() {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(_.last(transmitMessages).seq, sdps, 0));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  it('passes the translated InitialTransmitOfferRequestFlow test', () => {
    testInitialTransmitOfferRequestFlow();
  });

  it('passes the translated InitialTransmitOfferRequestFlowVersionTwo test', () => {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an offer response
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferResponseMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  });

  it('passes the translated InitialTransmitDuplicateOfferRequest test', () => {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // try transmitting a duplicate offer request.
    // this should be be rejected since we are in INIT_WAIT_RX_ANSWER
    assert.equal(-1, rs.transmitOfferRequest());
    assert.lengthOf(transmitMessages, 1);
  });

  function testInitialTransmitOfferFlow() {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 2);
    validateOkMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  it('passes the translated InitialTransmitOfferFlow test', () => {
    testInitialTransmitOfferFlow();
  });

  function testInitialTransmitOfferFlowVersionTwo() {
  // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 2);
    validateOkMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());
  }

  it('passes the translated InitialTransmitOfferFlowVersionTwo test', () => {
    testInitialTransmitOfferFlowVersionTwo();
  });

  it('passes the translated InitialTransmitDuplicateOffer test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // try transmitting a duplicate offer.
    // this should be be rejected since we are in INIT_WAIT_RX_ANSWER
    assert.equal(-1, rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
  });

  it('passes the translated InitialTransmitOfferWithDuplicateOk test', () => {
    // do transmit offer flow and store how many messages have been transmitted
    testInitialTransmitOfferFlow();
    const previousTransmitCount = (transmitMessages.length);

    // try transmitting a duplicate Ok message.
    // since in IDLE_LOCAL_OFFER, duplicate transmit of OK should be rejected
    assert.equal(-1, rs.transmitOk());
    assert.equal(previousTransmitCount, transmitMessages.length);
  });

  it('passes the translated InitialTransmitOfferWithErrorMessage test', () => {
    // do transmit offer flow and store how many messages have been transmitted
    testInitialTransmitOfferFlow();
    const previousTransmitCount = (transmitMessages.length);

    // try transmitting an error message.
    // since in IDLE_LOCAL_OFFER, transmit of error should be rejected
    assert.equal(-1, rs.transmitError('Test Error Msg'));
    assert.equal(previousTransmitCount, transmitMessages.length);
  });

  it('passes the translated InitialReceiveAnswerWithBadSeq test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receiving an answer message with the Seq number 1 higher than expected
    const lastTransmittedSeq = _.last(transmitMessages).seq;
    const answerMessage = new AnswerMessage(lastTransmittedSeq + 1, sdps);
    rs.receive(answerMessage);

    // since sequence number bad, we should not invoke answer received callback
    assert.lengthOf(receiveAnswerSdps, 0);

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.OOO);

    // state should NOT have changed
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
  });

  it('passes the translated ReceiveAnswerWithBadSeq test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with a lower tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker - 1;
    rs.receive(new OfferMessage(2, sdps, tieBreaker));

    // should NOT have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 0);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // trigger receiving an answer message
    const lastTransmittedSeq = _.last(transmitMessages).seq;
    const answerMessage = new AnswerMessage(lastTransmittedSeq + 1, sdps);
    rs.receive(answerMessage);

    // Since bad seq number, we should not invoke answer received callback
    assert.lengthOf(receiveAnswerSdps, 0);

    // should invoke the transmit callback with an error message
    validateErrorMessage(_.last(transmitMessages), 3, roapErrorType.OOO);

    // state should NOT have changed
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
  });

  it('passes the translated ReceiveDuplicateAnswer test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receiving an answer message
    const lastTransmittedSeq = _.last(transmitMessages).seq;
    const answerMessage = new AnswerMessage(lastTransmittedSeq, sdps);
    rs.receive(answerMessage);

    // we should have invoked answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should NOT have changed
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // try trigger receiving duplicate answer message with same sequence number
    rs.receive(answerMessage);

    // since duplicate answer with same sequence,
    // should not have invoked answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);

    // state should NOT have changed
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // try trigger receiving duplicate answer message with different sequence number
    answerMessage.seq += 1;
    rs.receive(answerMessage);

    // since duplicate answer with difference sequence,
    // should not have invoked answer received callback,
    // but should have sent error message
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_invalid_state);

    // state should NOT have changed
    assert.equal(rs.state, roapState.WAIT_TX_OK);
  });

  it('passes the translated InitialTransmitOfferWithDuplicateAnswer test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    const answerMessage = new AnswerMessage(_.last(transmitMessages).seq, sdps);
    rs.receive(answerMessage);

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 2);
    validateOkMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());

    // try trigger receiving duplicate answer message with same sequence number
    rs.receive(answerMessage);

    // since duplicate answer with same sequence,
    // should not have invoked answer receive callback,
    // but should have retransmitted ok message
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.lengthOf(transmitMessages, 3);
    assert.instanceOf(_.last(transmitMessages), OkMessage);

    // state should NOT have changed
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);

    // try trigger receiving duplicate answer message with different sequence number
    answerMessage.seq += 1;
    rs.receive(answerMessage);

    // since duplicate answer with difference sequence,
    // should have invoked answer received callback,
    // and should not have sent error message
    assert.lengthOf(receiveAnswerSdps, 2);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // should not invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 3);

    // state should NOT have changed
    assert.equal(rs.state, roapState.WAIT_TX_OK);
  });

  it('passes the translated InitialTransmitOfferWithDuplicateAnswerAfterError test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an answer
    const answerMessage = new AnswerMessage(_.last(transmitMessages).seq, sdps);
    rs.receive(answerMessage);

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an error
    assert.doesNotThrow(() => rs.transmitError('incompatible codec(s)'));

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_failed);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
    assert.isFalse(rs.isTransactionInProgress());

    // try trigger receiving duplicate answer message with same sequence number
    rs.receive(answerMessage);

    // since duplicate answer with same sequence and we don't have an ok
    // previously, the answer should have been processed and answer receive callback should have been invoked
    assert.lengthOf(receiveAnswerSdps, 2);

    // trigger transmission of an error again
    assert.doesNotThrow(() => rs.transmitError('incompatible codec(s)'));

    assert.lengthOf(transmitMessages, 3);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_failed);

    // state should NOT have changed
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  function testReceiveSubsequentOfferRequestFlow() {
    testInitialReceiveOfferRequestFlow();
    doReceiveSubsequentOfferRequestFlow();
  }

  it('passes the translated ReceiveSubsequentOfferRequestFlow test', () => {
    testReceiveSubsequentOfferRequestFlow();
  });

  it('passes the translated ReceiveSubsequentOfferRequestFlow2 test', () => {
    testInitialReceiveOfferFlow();
    doReceiveSubsequentOfferRequestFlow();
  });

  it('passes the translated ReceiveSubsequentOfferRequestFlow3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doReceiveSubsequentOfferRequestFlow();
  });

  it('passes the translated ReceiveSubsequentOfferRequestFlow4 test', () => {
    testInitialTransmitOfferFlow();
    doReceiveSubsequentOfferRequestFlow();
  });

  function testReceiveSubsequentOfferFlow() {
    testInitialReceiveOfferFlow();
    doReceiveSubsequentOfferFlow();
  }

  it('passes the translated ReceiveSubsequentOfferFlow test', () => {
    testReceiveSubsequentOfferFlow();
  });

  it('passes the translated ReceiveSubsequentOfferFlow2 test', () => {
    testInitialReceiveOfferFlow();
    doReceiveSubsequentOfferFlow();
  });

  it('passes the translated ReceiveSubsequentOfferFlow3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doReceiveSubsequentOfferFlow();
  });

  it('passes the translated ReceiveSubsequentOfferFlow4 test', () => {
    testInitialTransmitOfferFlow();
    doReceiveSubsequentOfferFlow();
  });

  it('passes the translated ReceiveDuplicateOfferRequest test', () => {
    // trigger receive of an offer request
    const offerRequestMessage = new OfferRequestMessage(1, 0);
    rs.receive(offerRequestMessage);

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);

    // try trigger receive of an exact duplicate offer request.
    // since seq number the same, this should be ignored.
    rs.receive(offerRequestMessage);

    // verify this duplicate offer request was not processed
    assert.equal(receiveOfferRequestCount, 1);

    // verify seq number and increment it
    assert.equal(offerRequestMessage.seq, 1);
    offerRequestMessage.seq += 1;

    // trigger receive of another offer request with higher seq number.
    rs.receive(offerRequestMessage);

    // since seq number higher, verify this valid new event is processed
    assert.equal(receiveOfferRequestCount, 2);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
  });

  function testTransmitSubsequentOfferFlow() {
    testInitialReceiveOfferRequestFlow();
    doTransmitSubsequentOffer();
  }

  it('passes the translated TransmitSubsequentOfferFlow test', () => {
    testTransmitSubsequentOfferFlow();
  });

  it('passes the translated TransmitSubsequentOfferFlow2 test', () => {
    testInitialReceiveOfferFlow();
    doTransmitSubsequentOffer();
  });

  it('passes the translated TransmitSubsequentOfferFlow3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doTransmitSubsequentOffer();
  });

  it('passes the translated TransmitSubsequentOfferFlow4 test', () => {
    testInitialTransmitOfferFlow();
    doTransmitSubsequentOffer();
  });

  it('passes the translated TransmitSubsequentOfferFlowRetry test', () => {
    testInitialTransmitOfferFlow();


    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);

    // trigger receive of a retry error
    rs.receive(new ErrorMessage(_.last(transmitMessages).seq, roapErrorType.type_retry, 'errorCause'));

    // should invoke the transmit callback with retry of offer message with new seqnum
    assert.lengthOf(transmitMessages, 2);
    validateOfferMessage(_.last(transmitMessages), 3, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());
  });

  function testTransmitSubsequentOfferRequestFlow() {
    testInitialReceiveOfferRequestFlow();
    doTransmitSubsequentOfferRequest();
  }

  it('passes the translated TransmitSubsequentOfferRequestFlow test', () => {
    testTransmitSubsequentOfferRequestFlow();
  });

  it('passes the translated TransmitSubsequentOfferRequestFlow2 test', () => {
    testInitialReceiveOfferFlow();
    doTransmitSubsequentOfferRequest();
  });

  it('passes the translated TransmitSubsequentOfferRequestFlow3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doTransmitSubsequentOfferRequest();
  });

  it('passes the translated TransmitSubsequentOfferRequestFlow4 test', () => {
    testInitialTransmitOfferFlow();
    doTransmitSubsequentOfferRequest();
  });

  it('passes the translated TransmitSubsequentOfferRequestFlowRetry test', () => {
    testInitialTransmitOfferFlow();


    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 2);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of a retry error
    rs.receive(new ErrorMessage(_.last(transmitMessages).seq, roapErrorType.type_retry, 'errorCause'));

    // should invoke the transmit callback with retry of offer request message with new seqnum
    assert.lengthOf(transmitMessages, 2);
    validateOfferRequestMessage(_.last(transmitMessages), 3);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());
  });

  it('passes the translated TransmitOfferWhenWaitingForRxOk test', () => {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(_.last(transmitMessages).seq, sdps, 0));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmit of a new offer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // offer should be processed and transmit callback invoked with an offer message
    assert.lengthOf(transmitMessages, 3);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());
  });

  it('passes the translated TransmitOfferRequestWhenWaitingForRxOk test', () => {
    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());

    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(_.last(transmitMessages).seq, sdps, 0));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger transmit of another offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // request should be processed and transmit callback invoked with an offer request message
    assert.lengthOf(transmitMessages, 3);
    validateOfferRequestMessage(_.last(transmitMessages), 2);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());
  });


  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest test', () => {
    testInitialReceiveOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest2 test', () => {
    testInitialReceiveOfferFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest4 test', () => {
    testInitialTransmitOfferFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest5 test', () => {
    testReceiveSubsequentOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest6 test', () => {
    testReceiveSubsequentOfferFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest7 test', () => {
    testTransmitSubsequentOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOfferRequest8 test', () => {
    testTransmitSubsequentOfferFlow();
    doReceiveOutOfOrderSubsequentOfferRequest();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer test', () => {
    testInitialReceiveOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer2 test', () => {
    testInitialReceiveOfferFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer3 test', () => {
    testInitialTransmitOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer4 test', () => {
    testInitialTransmitOfferFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer5 test', () => {
    testReceiveSubsequentOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer6 test', () => {
    testReceiveSubsequentOfferFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer7 test', () => {
    testTransmitSubsequentOfferRequestFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveOutOfOrderSubsequentOffer8 test', () => {
    testTransmitSubsequentOfferFlow();
    doReceiveOutOfOrderSubsequentOffer();
  });

  it('passes the translated ReceiveDuplicateOffer test', () => {
    // trigger receive of an offer request
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(1, sdps, 0);
    rs.receive(offerMessage);

    // should have invoked callback that an offer was received
    assert.lengthOf(receiveOfferSdps, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // try trigger receive of an exact duplicate offer.
    // since seq number the same, this should be ignored.
    rs.receive(offerMessage);
    // verify this duplicate offer was not processed
    assert.lengthOf(receiveOfferSdps, 1);

    // verify seq number and increment it
    assert.equal(offerMessage.seq, 1);
    offerMessage.seq += 1;

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger receive of another offer with higher seq number.
    rs.receive(offerMessage);

    // since seq number higher, verify this valid new event is processed
    assert.lengthOf(receiveOfferSdps, 2);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
  });

  it('passes the translated ReceiveOfferWhenWaitingForOk test', () => {
    // trigger receive of an initial offer
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(1, sdps, 0);
    rs.receive(offerMessage);

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // simulate receiving an exact duplicate offer.
    // this may happen if remote side did not receive our answer.
    // since seq number the same, we should transmit duplicate answer
    rs.receive(offerMessage);

    // verify this duplicate offer was not fully processed as a new event,
    // since seq number was the same
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(offerMessage.seq, 1);

    // since seq number the same, we should have transmitted the duplicate answer
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // increment seq number to simulate new offer event
    assert.equal(offerMessage.seq, 1);
    offerMessage.seq += 1;

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // trigger receive of another offer with higher seq number.
    rs.receive(offerMessage);

    // should have injected a 'fake' ok callback
    assert.equal(receiveOkCount, 1);

    // since seq number higher, verify this valid new event is processed
    assert.lengthOf(receiveOfferSdps, 2);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
  });

  it('passes the translated ReceiveOfferWhenWaitingForTxOk test', () => {
    doInitialReceiveOfferRequestFlow(false);

    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(2, sdps, 2);

    // trigger receive of another offer with higher seq number.
    rs.receive(offerMessage);

    // since seq number higher, verify this valid new event is processed
    assert.lengthOf(receiveOfferSdps, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // now if something triggers an ok to be sent, it will just get ignored
    assert.equal(-1, rs.transmitOk());
    assert.lengthOf(transmitMessages, 0);

    // state should still be the same
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
  });

  it('passes the translated ReceiveOfferRequestWhenWaitingForOk test', () => {
    // trigger receive of an initial offer
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(1, sdps, 0);
    rs.receive(offerMessage);

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // simulate receiving an offer request with the same sequence
    // number.
    const offerRequestMessage = new OfferRequestMessage(1, 0);
    rs.receive(offerRequestMessage);

    // this should be rejected with an invalid state error
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_invalid_state);

    // verify this offer request was not fully processed as a new
    // event, since seq number was the same
    assert.equal(receiveOfferRequestCount, 0);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // increment seq number to simulate new offer event
    offerRequestMessage.seq += 1;

    // trigger receive of another offer with higher seq number.
    rs.receive(offerRequestMessage);

    // should have injected a 'fake' ok callback
    assert.equal(receiveOkCount, 1);

    // since seq number higher, verify this valid new event is processed
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
  });

  it('passes the translated ReceiveOfferRequestWhenWaitingForTxOk test', () => {
    doInitialReceiveOfferRequestFlow(false);

    const offerRequestMessage = new OfferRequestMessage(2, 1);

    // trigger receive of another offer with higher seq number.
    rs.receive(offerRequestMessage);

    // since seq number higher, verify this valid new event is processed
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);

    // now if something triggers an ok to be sent, it will just get ignored
    assert.equal(-1, rs.transmitOk());
    assert.lengthOf(transmitMessages, 0);

    // state should still be the same
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
  });

  it('passes the translated OfferRequestOfferRequestGlareLocalLose test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with a higher tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker + 1;
    rs.receive(new OfferRequestMessage(2, tieBreaker));

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);

    // send in the ERROR:CONFLICT message from the remote side
    // (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 2);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, true);

    // send in another ERROR:CONFLICT message from the remote
    // side, testing conflict being received before or after our
    // offer goes out.  (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 3);
    validateOkMessage(_.last(transmitMessages), 2);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated OfferRequestOfferRequestGlareLocalWin test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with a lower tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker - 1;
    rs.receive(new OfferRequestMessage(2, tieBreaker));

    // should NOT have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);

    // should send out an ERROR:CONFLICT message (the tieBreaker
    // winner sends this)
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_conflict);

    // trigger reception of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(2, sdps, 0));

    // should invoke the offer received callback
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be right
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 3);
    validateAnswerMessage(_.last(transmitMessages), 2, sdps);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be right
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
  });

  it('passes the translated OfferRequestOfferRequestGlareLocalTie test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with the same tie-breaker
    const {tieBreaker} = _.last(transmitMessages);
    rs.receive(new OfferRequestMessage(2, tieBreaker));

    // should NOT have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // should send out an ERROR:DOUBLE_CONFLICT and OFFER_REQUEST message
    assert.lengthOf(transmitMessages, 3);
    validateErrorMessage(transmitMessages[1], 2, roapErrorType.type_double_conflict);
    validateOfferRequestMessage(transmitMessages[2], 3);

    // tieBreaker should have anew value
    assert.notEqual(transmitMessages[2].tieBreaker, tieBreaker);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);

    // send in the ERROR:DOUBLE_CONFLICT message from the remote side
    rs.receive(new ErrorMessage(2, roapErrorType.type_double_conflict, 'errorCause'));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
  });

  it('passes the translated OfferRequestOfferRequestGlareNoTieBreaker test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with NO tie-breaker
    const offerRequestMessage = new OfferRequestMessage(2, 0);
    offerRequestMessage.tieBreaker = undefined;
    rs.receive(offerRequestMessage);

    // should NOT have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // should have sent an error message
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_failed);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
  });

  it('passes the translated OfferRequestReceiveNewerOfferRequestGlare test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with NO tie-breaker and a
    // higher/newer sequence number
    const offerRequestMessage = new OfferRequestMessage(4, 0);
    offerRequestMessage.tieBreaker = undefined;
    rs.receive(offerRequestMessage);

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // Since remote has higher seq number, we lose glare and should
    // transition from WAIT_RX_OFFER to WAIT_TX_OFFER
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);
  });

  it('passes the translated OfferRequestReceiveOlderOfferRequestGlare test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // send in a remote offer request with NO tie-breaker and a
    // lower/older sequence number
    const offerRequestMessage = new OfferRequestMessage(1, 0);
    offerRequestMessage.tieBreaker = undefined;
    rs.receive(offerRequestMessage);

    // since lower/older sequence number, we should NOT have
    // invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // should have sent an error message for older message
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.OOO);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OFFER);
  });

  it('passes the translated OfferOfferGlareLocalLose test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with a higher tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker + 1;
    rs.receive(new OfferMessage(2, sdps, tieBreaker));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // send in the ERROR:CONFLICT message from the remote side
    // (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
  });

  it('passes the translated OfferOfferGlareLocalLoseErrorAfterTxAnswer test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with a higher tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker + 1;
    rs.receive(new OfferMessage(2, sdps, tieBreaker));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // send in the ERROR:CONFLICT message from the remote side
    // (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // trigger receive of an ok
    rs.receive(new OkMessage(_.last(transmitMessages).seq));

    // should have invoked callback that ok was received
    assert.equal(receiveOkCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
  });

  it('passes the translated OfferOfferGlareLocalWin test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with a lower tie-breaker
    const tieBreaker = _.last(transmitMessages).tieBreaker - 1;
    rs.receive(new OfferMessage(2, sdps, tieBreaker));

    // should NOT have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 0);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // should send out an ERROR:CONFLICT message (the tieBreaker
    // winner sends this)
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_conflict);

    // trigger reception of an answer
    rs.receive(new AnswerMessage(2, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 3);
    validateOkMessage(_.last(transmitMessages), 2);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated OfferOfferGlareLocalTie test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with the same tiebreaker
    const {tieBreaker} = _.last(transmitMessages);
    rs.receive(new OfferMessage(2, sdps, tieBreaker));

    // should NOT have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 0);

    // should send out an ERROR:DOUBLE_CONFLICT message
    assert.lengthOf(transmitMessages, 3);
    validateErrorMessage(transmitMessages[1], 2, roapErrorType.type_double_conflict);

    // should send out a new offer with a new sequence number and tiebreaker
    validateOfferMessage(transmitMessages[2], 3, sdps, false);
    assert.notEqual(transmitMessages[2].tieBreaker, tieBreaker);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // send in the ERROR:DOUBLE_CONFLICT message from the remote side
    rs.receive(new ErrorMessage(2, roapErrorType.type_double_conflict, 'errorCause'));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
  });

  function testOfferOfferGlareNoTieBreaker() {
  // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer with NO tie-breaker
    const offerMessage = new OfferMessage(2, sdps, 0);
    offerMessage.tieBreaker = undefined;
    rs.receive(offerMessage);

    // should NOT have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 0);

    // should have sent an error message
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_failed);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
  }

  it('passes the translated OfferOfferGlareNoTieBreaker test', () => {
    testOfferOfferGlareNoTieBreaker();
  });

  it('passes the translated OfferReceiveNewerOfferGlare test', () => {
    // set things up
    testOfferOfferGlareNoTieBreaker();

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // send in a remote offer request with NO tie-breaker and a
    // higher/newer sequence number
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(4, sdps, 0);
    rs.receive(offerMessage);

    // should have invoked callback that an offer was received
    assert.lengthOf(receiveOfferSdps, 1);

    // Since remote has higher seq number, we lose glare and should
    // transition from WAIT_RX_ANSWER to WAIT_TX_ANSWER
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
  });

  it('passes the translated OfferRequestOfferGlareLocalLose test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer request
    rs.receive(new OfferRequestMessage(2, 0xFFFFFFFF));

    // should NOT have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 0);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // should have re-transmitted our last offer
    assert.lengthOf(transmitMessages, 2);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, true);

    // send in the ERROR:CONFLICT message from the remote side
    // (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 3);
    validateOkMessage(_.last(transmitMessages), 2);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated OfferRequestOfferGlareLocalLoseVersionTwo test', () => {
    // set things up
    testInitialTransmitOfferFlowVersionTwo();

    // trigger transmission of a subsequent offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // send in a remote offer request
    rs.receive(new OfferRequestMessage(2, 0xFFFFFFFF));

    // should have invoked callback that an offer request was received
    assert.equal(receiveOfferRequestCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OFFER);

    // trigger transmission of our offer again
    sdps.resize(1);
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER_RESPONSE);

    // should have transmitted our last offer
    assert.lengthOf(transmitMessages, 2);
    validateOfferResponseMessage(_.last(transmitMessages), 2, sdps);

    // send in the ERROR:CONFLICT message from the remote side
    // (the tieBreaker winner sends this)
    rs.receive(new ErrorMessage(2, roapErrorType.type_conflict, 'errorCause'));

    // state should still be correct
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER_RESPONSE);

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // should invoke the answer received callback
    assert.lengthOf(receiveAnswerSdps, 1);
    assert.equal(sdps, _.last(receiveAnswerSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_OK);

    // trigger transmission of an ok
    assert.doesNotThrow(() => rs.transmitOk());

    // should invoke the transmit callback with an ok message
    assert.lengthOf(transmitMessages, 3);
    validateOkMessage(_.last(transmitMessages), 2);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated TransmitOfferEmptySDPs test', () => {
    // trigger transmission of an offer with empty sdps
    const sdps = [];
    assert.equal(-1, rs.transmitOffer(sdps));

    // should NOT invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 0);
  });

  it('passes the translated TransmitDuplicateOffer test', () => {
    // get the initial stuff out of the way
    testInitialTransmitOfferFlow();


    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // try transmitting another offer. this is an error
    assert.equal(-1, rs.transmitOffer(sdps));

    // this should NOT invoke transmit callback with another offer message
    assert.lengthOf(transmitMessages, 1);

    // state should still be right
    assert.equal(rs.state, roapState.WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());
  });

  it('passes the translated TransmitAnswerEmptySDPs test', () => {
    // trigger receive of an initial offer request
    let sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // trigger transmission of an answer with empty sdps
    sdps = [];
    assert.equal(-1, rs.transmitAnswer(sdps));

    // should NOT invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 0);
  });

  it('passes the translated TransmitDuplicateAnswer test', () => {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // try to trigger transmission of another answer.
    // in WAIT_RX_OK state, this should get rejected without another transmit
    assert.equal(-1, rs.transmitAnswer(sdps));
    assert.lengthOf(transmitMessages, 1);
  });

  it('passes the translated NoRetransmitInitialOfferRequest test', () => {
    // set the retransmission interval and timeout to be very low
    rs.retransmitDuration = 0;
    rs.transactionTimeoutDuration = 0;

    testInitialTransmitOfferFlowVersionTwo();

    // should not retransmit
    const xmitCount = transmitMessages.length;

    // retransmit timer should run and transaction timeout timer should pop
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    assert.equal(xmitCount, transmitMessages.length);

    // should not reschedule
    // assert.lengthOf(context.GetIOService().run_one(), 0);

    // should not timeout
    assert.equal(timeoutCount, 0);
  });

  it('passes the translated NoRetransmitInitialOffer test', () => {
    // set the retransmission interval and timeout to be very low
    rs.retransmitDuration = 0;
    rs.transactionTimeoutDuration = 0;

    testInitialTransmitOfferFlow();

    // should not retransmit
    const xmitCount = transmitMessages.length;

    // retransmit timer should run and transaction timeout timer should pop
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    assert.equal(xmitCount, transmitMessages.length);

    // should not reschedule
    // assert.lengthOf(context.GetIOService().run_one(), 0);

    // should not timeout
    assert.equal(timeoutCount, 0);
  });

  it('passes the translated RetransmitInitialOfferRequest test', () => {
    // set the retransmission interval to be very low
    rs.retransmitDuration = 0;

    // send an offer
    assert.doesNotThrow(() => rs.transmitOfferRequest());
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // should retransmit
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    assert.lengthOf(transmitMessages, 2);
    validateOfferRequestMessage(_.last(transmitMessages), 1);
  });

  it('passes the translated RetransmitInitialOffer test', () => {
    // set the retransmission interval to be very low
    rs.retransmitDuration = 0;

    // send an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // should retransmit
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    assert.lengthOf(transmitMessages, 2);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);
  });

  it('passes the translated RetransmitSubsequentOfferRequest test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // set the retransmission interval to be very low
    rs.retransmitDuration = 0;

    // send an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 2);

    // process the initial timer cancellation plus the timeout timer cancellation,
    // then should retransmit
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    assert.lengthOf(transmitMessages, 2);
    validateOfferRequestMessage(_.last(transmitMessages), 2);
  });

  it('passes the translated RetransmitSubsequentOffer test', () => {
    // set things up
    testInitialTransmitOfferFlow();

    // set the retransmission interval to be very low
    rs.retransmitDuration = 0;

    // send an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);

    // process the initial timer cancellation plus the timeout timer cancellation,
    // then should retransmit
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    assert.lengthOf(transmitMessages, 2);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);
  });

  it('passes the translated RetransmitAnswer test', () => {
    // set the retransmission interval to be very low
    rs.retransmitDuration = 0;

    // receive an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // should retransmit
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);
  });

  it('passes the translated InitialReceiveOfferRequestFlowReceiveError test', () => {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage());

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // trigger receive of an error
    rs.receive(new ErrorMessage(_.last(transmitMessages).seq, roapErrorType.type_failed, 'errorCause'));

    // should invoke the error callback
    assert.equal(receiveErrorCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  function testInitialReceiveOfferFlowReceiveError() {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // trigger receive of an error
    rs.receive(new ErrorMessage(_.last(transmitMessages).seq, roapErrorType.type_failed, 'errorCause'));

    // should invoke the error callback
    assert.equal(receiveErrorCount, 1);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  }

  it('passes the translated InitialReceiveOfferFlowReceiveError test', () => {
    testInitialReceiveOfferFlowReceiveError();
  });

  it('passes the translated InitialReceiveOfferRequestFlowTransmitErrorOnOfferRequest test', () => {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage());

    // trigger transmission of an error
    assert.doesNotThrow(() => rs.transmitError('errorCause'));

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_failed);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated InitialReceiveOfferRequestFlowTransmitErrorOnAnswer test', () => {
    // trigger receive of an initial offer request
    rs.receive(new OfferRequestMessage());

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // trigger receive of an answer
    rs.receive(new AnswerMessage(_.last(transmitMessages).seq, sdps));

    // trigger transmission of an error
    assert.doesNotThrow(() => rs.transmitError('errorCause'));

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_failed);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_LOCAL_OFFER);
  });

  it('passes the translated InitialReceiveOfferFlowTransmitError test', () => {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // trigger transmission of an error
    assert.doesNotThrow(() => rs.transmitError('errorCause'));

    // should invoke the transmit callback with an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 1, roapErrorType.type_failed);

    // state should be correct
    assert.equal(rs.state, roapState.IDLE_REMOTE_OFFER);
  });

  it('passes the translated ReceiveAnswerWhenInErrorState test', () => {
    // set things up, and begin in ERROR state
    testInitialReceiveOfferFlowReceiveError();

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);

    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new AnswerMessage(2, sdps));

    // in ERROR state, should not have invoked callback for answer
    assert.lengthOf(receiveAnswerSdps, 0);

    // validate we send out an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_invalid_state);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  it('passes the translated ReceiveErrorWhenInErrorState test', () => {
    // set things up, and begin in ERROR state
    testInitialReceiveOfferFlowReceiveError();

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);

    // trigger receive of an error
    rs.receive(new ErrorMessage(2, roapErrorType.type_failed, 'errorCause'));

    // should not invoke the error callback when already in ERROR state
    assert.equal(receiveErrorCount, 0);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  it('passes the translated ReceiveOfferRequestWhenInErrorState test', () => {
    // set things up, and begin in ERROR state
    testInitialReceiveOfferFlowReceiveError();

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);

    // trigger receive of an offer request
    rs.receive(new OfferRequestMessage(2, 0));

    // in ERROR state, should not have invoked callback for offer request
    assert.equal(receiveOfferRequestCount, 0);

    // validate we send out an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_invalid_state);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  it('passes the translated ReceiveOfferWhenInErrorState test', () => {
    // set things up, and begin in ERROR state
    testInitialReceiveOfferFlowReceiveError();

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);

    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(2, sdps, 0));

    // in ERROR state, should not have invoked callback for offer
    assert.lengthOf(receiveOfferSdps, 0);

    // validate we send out an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_invalid_state);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  it('passes the translated ReceiveOkWhenInErrorState test', () => {
    // set things up, and begin in ERROR state
    testInitialReceiveOfferFlowReceiveError();

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);

    // trigger receive of an ok
    rs.receive(new OkMessage(2));

    // in ERROR state, should not have invoked callback for ok
    assert.equal(receiveOkCount, 0);

    // validate we send out an error message
    assert.lengthOf(transmitMessages, 1);
    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_invalid_state);

    // state should be correct
    assert.equal(rs.state, roapState.ERROR);
  });

  it('passes the translated BadFollowUpOfferWithMissingAnswerSessionId test', () => {
    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // should have invoked callback that offer was received
    assert.lengthOf(receiveOfferSdps, 1);
    assert.equal(sdps, _.last(receiveOfferSdps));

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);
    assert(rs.isTransactionInProgress());

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an answer message
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 1, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);
    assert(rs.isTransactionInProgress());

    // trigger receive of a new offer with a missing answer session id
    const {seq} = _.last(transmitMessages);
    const badOfferMsg = fromObject({
      messageType: 'OFFER',
      seq,
      sdps
    });

    // receive the bad message
    rs.receive(badOfferMsg);

    // validate we send out an error message
    assert.lengthOf(transmitMessages, 2);
    validateErrorMessage(_.last(transmitMessages), seq, roapErrorType.type_nomatch);
  });

  it('passes the translated GetLastReceiveMessage test', () => {
    // initially there is no message
    assert.isFalse(rs.getLastReceiveMessage());

    // send in something invalid
    let message = new OfferRequestMessage();
    message.version = 'foobar';
    rs.receive(message);

    // still no message
    assert.isFalse(rs.getLastReceiveMessage());

    message = new OfferRequestMessage();
    rs.receive(message);

    // now we have a good message
    assert(rs.getLastReceiveMessage());
    assert.equal(message.messageType, rs.getLastReceiveMessage().messageType);
  });

  it('passes the translated RemoteVersionChangeAfterInitialFlow test', () => {
    // an arbitrary initial flow
    testInitialReceiveOfferRequestFlow();

    // now send in a message with a changed version
    const message = new OfferRequestMessage(2, 0);
    rs.receive(message);

    // should NOT invoke callback
    assert.equal(receiveOfferRequestCount, 0);

    validateErrorMessage(_.last(transmitMessages), 2, roapErrorType.type_refused);
  });

  it('passes the translated InitialOfferRequestTimeout test', () => {
    // set timeout to be very low
    rs.transactionTimeoutDuration = 0;

    // send an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 1);

    // should timeout
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    // should invoke timeout callback
    assert.equal(timeoutCount, 1);
  });

  it('passes the translated InitialOfferTimeout test', () => {
    // set timeout to be very low
    rs.transactionTimeoutDuration = 0;

    // send an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 1, sdps, false);

    // should timeout
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    // should invoke timeout callback
    assert.equal(timeoutCount, 1);
  });

  it('passes the translated SubsequentOfferRequestTimeout test', () => {
    // set retransmit and timeout to be very low
    rs.retransmitDuration = 0;
    rs.transactionTimeoutDuration = 0;

    // first offer/answer succeeded
    testInitialReceiveOfferFlowVersionTwo();

    // clear transmit message
    transmitMessages = [];

    // send an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());
    assert.lengthOf(transmitMessages, 1);
    validateOfferRequestMessage(_.last(transmitMessages), 2);

    // clear transmit message
    transmitMessages = [];

    // let it run some
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    // there should be some retransmit
    assert.isAbove(transmitMessages.length, 0);

    // and timeout callback
    assert.equal(timeoutCount, 1);
  });

  it('passes the translated SubsequentOfferTimeout test', () => {
    // set retransmit and timeout to be very low
    rs.retransmitDuration = 0;
    rs.transactionTimeoutDuration = 0;

    // first offer/answer succeeded
    testInitialReceiveOfferFlow();

    // clear transmit message
    transmitMessages = [];

    // send an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));
    assert.lengthOf(transmitMessages, 1);
    validateOfferMessage(_.last(transmitMessages), 2, sdps, false);

    // clear transmit message
    transmitMessages = [];

    // let it run some
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    // there should be some retransmit
    assert.isAbove(transmitMessages.length, 0);

    // and timeout callback
    assert.equal(timeoutCount, 1);
  });

  it('passes the translated OfferAnswerNoOkTimeout test', () => {
    // set retransmit and timeout to be very low
    rs.retransmitDuration = 0;
    rs.transactionTimeoutDuration = 0;

    // trigger receive of an initial offer request
    const sdps = ['sdp1', 'sdp2'];
    rs.receive(new OfferMessage(sdps));

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // let it run
    // assert.lengthOf(context.GetIOService().run_one(), 1);
    // assert.lengthOf(context.GetIOService().run_one(), 1);

    // there should be a timeout callback
    assert.equal(timeoutCount, 1);
  });

  it('passes the translated ReceiveOutOfOrderOutOfOrderError test', () => {
    // get initial stuff out of the way
    testInitialReceiveOfferFlow();


    // trigger receive of an offer
    const sdps = ['sdp1', 'sdp2'];
    const offerMessage = new OfferMessage(2, sdps, 0);
    rs.receive(offerMessage);

    // should have invoked callback that an offer was received
    assert.lengthOf(receiveOfferSdps, 1);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // an answer should be transmitted
    assert.lengthOf(transmitMessages, 1);
    validateAnswerMessage(_.last(transmitMessages), 2, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // now trigger receive of another offer with higher seq number
    offerMessage.seq += 1;
    rs.receive(offerMessage);

    // verify this is processed
    assert.lengthOf(receiveOfferSdps, 2);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_TX_ANSWER);

    // trigger transmission of an answer
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // an answer should be transmitted
    assert.lengthOf(transmitMessages, 2);
    validateAnswerMessage(_.last(transmitMessages), 3, sdps);

    // state should be correct
    assert.equal(rs.state, roapState.WAIT_RX_OK);

    // our previous answer got an ooo error with old sequence number
    rs.receive(new ErrorMessage(2, roapErrorType.OOO,
      'received seq 2 expected at least 3'));

    // this should *not* trigger another ooo error on our side
    assert.lengthOf(transmitMessages, 2);
  });

  it('passes the translated ReceiveInvalidMessageStats test', () => {
    testInitialTransmitOfferFlow();

    // receive an offer with old seq number
    const offer = new OfferMessage(0, ['sdp'], 0);
    rs.receive(offer);

    // receive an invalid message (offer with no sdp)
    offer.seq = 2;
    offer.sdps = undefined;

    rs.receive(offer);
  });

  it('passes the translated StartingSeqNumber test', () => {
    rs = new ROAPSession(6);

    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);

    // seq number should be right (last seq was 6, so this transaction should be 7)
    validateOfferMessage(_.last(transmitMessages), 7, sdps, false);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_ANSWER);
    assert(rs.isTransactionInProgress());

    // another try, this time starting with an offer request
    rs = new ROAPSession(100);

    // trigger transmission of an offer request
    assert.doesNotThrow(() => rs.transmitOfferRequest());

    // should invoke the transmit callback with an offer request message
    assert.lengthOf(transmitMessages, 1);
    // sequence number should be right
    validateOfferRequestMessage(_.last(transmitMessages), 101);

    // state should be right
    assert.equal(rs.state, roapState.INIT_WAIT_RX_OFFER);
    assert(rs.isTransactionInProgress());
  });

  it('passes the translated GetCurrentSeqNumber test', () => {
    // trigger transmission of an offer
    const sdps = ['sdp1', 'sdp2'];
    assert.doesNotThrow(() => rs.transmitOffer(sdps));

    // should invoke the transmit callback with an offer message
    assert.lengthOf(transmitMessages, 1);

    // seq number should be right
    validateOfferMessage(_.last(transmitMessages), rs.seq, sdps, false);
  });


//   // describe('in the default state', () => {
//   //   it('has the correct values', () => {
//   //     assert.equal(session.state, roapState.INIT);
//   //     assert.isFalse(session.isTransactionInProgress());
//   //   });
//   // });

//   // describe('')

//   // testBadFollowUpOfferWithMissingAnswerSessionId
//   // testGetCurrentSeqNumber
//   // testGetLastReceiveMessage
//   // testGetVersion
//   // testInitialOfferRequestTimeout
//   // testInitialOfferTimeout
//   // testInitialReceiveAnswerWithBadSeq
//   // testInitialReceiveBadOffer
//   // testInitialReceiveOfferFlow
//   // testInitialReceiveOfferFlowDuplicateOk
//   // testInitialReceiveOfferFlowReceiveError
//   // testInitialReceiveOfferFlowTransmitError
//   // testInitialReceiveOfferFlowVersionTwo
//   // testInitialReceiveOfferRequestFlow
//   // testInitialReceiveOfferRequestFlowReceiveError
//   // testInitialReceiveOfferRequestFlowTransmitErrorOnAnswer
//   // testInitialReceiveOfferRequestFlowTransmitErrorOnOfferRequest
//   // testInitialReceiveOfferRequestFlowVersionThree
//   // testInitialReceiveOfferRequestFlowVersionTwo
//   // testInitialTransmitDuplicateOffer
//   // testInitialTransmitDuplicateOfferRequest
//   // testInitialTransmitOfferFlow
//   // testInitialTransmitOfferFlowStats
//   // testInitialTransmitOfferFlowVersionTwo
//   // testInitialTransmitOfferRequestFlow
//   // testInitialTransmitOfferRequestFlowVersionTwo
//   // testInitialTransmitOfferWithDuplicateAnswer
//   // testInitialTransmitOfferWithDuplicateAnswerAfterError
//   // testInitialTransmitOfferWithDuplicateOk
//   // testInitialTransmitOfferWithErrorMessage
//   // testNoRetransmitInitialOffer
//   // testNoRetransmitInitialOfferRequest
//   // testOfferAnswerNoOkTimeout
//   // testOfferOfferGlareLocalLose
//   // testOfferOfferGlareLocalLoseErrorAfterTxAnswer
//   // testOfferOfferGlareLocalTie
//   // testOfferOfferGlareLocalWin
//   // testOfferOfferGlareNoTieBreaker
//   // testOfferReceiveNewerOfferGlare
//   // testOfferRequestOfferGlareLocalLose
//   // testOfferRequestOfferGlareLocalLoseVersionTwo
//   // testOfferRequestOfferRequestGlareLocalLose
//   // testOfferRequestOfferRequestGlareLocalTie
//   // testOfferRequestOfferRequestGlareLocalWin
//   // testOfferRequestOfferRequestGlareNoTieBreaker
//   // testOfferRequestReceiveNewerOfferRequestGlare
//   // testOfferRequestReceiveOlderOfferRequestGlare
//   // testReceiveAnswerWhenInErrorState
//   // testReceiveAnswerWithBadSeq
//   // testReceiveDuplicateAnswer
//   // testReceiveDuplicateOffer
//   // testReceiveDuplicateOfferRequest
//   // testReceiveErrorWhenInErrorState
//   // testReceiveInvalidMessageStats
//   // testReceiveOfferRequestWhenInErrorState
//   // testReceiveOfferRequestWhenWaitingForOk
//   // testReceiveOfferRequestWhenWaitingForTxOk
//   // testReceiveOfferWhenInErrorState
//   // testReceiveOfferWhenWaitingForOk
//   // testReceiveOfferWhenWaitingForTxOk
//   // testReceiveOkWhenInErrorState
//   // testReceiveOutOfOrderOutOfOrderError
//   // testReceiveOutOfOrderSubsequentOffer
//   // testReceiveOutOfOrderSubsequentOffer2
//   // testReceiveOutOfOrderSubsequentOffer3
//   // testReceiveOutOfOrderSubsequentOffer4
//   // testReceiveOutOfOrderSubsequentOffer5
//   // testReceiveOutOfOrderSubsequentOffer6
//   // testReceiveOutOfOrderSubsequentOffer7
//   // testReceiveOutOfOrderSubsequentOffer8
//   // testReceiveOutOfOrderSubsequentOfferRequest
//   // testReceiveOutOfOrderSubsequentOfferRequest2
//   // testReceiveOutOfOrderSubsequentOfferRequest3
//   // testReceiveOutOfOrderSubsequentOfferRequest4
//   // testReceiveOutOfOrderSubsequentOfferRequest5
//   // testReceiveOutOfOrderSubsequentOfferRequest6
//   // testReceiveOutOfOrderSubsequentOfferRequest7
//   // testReceiveOutOfOrderSubsequentOfferRequest8
//   // testReceiveSubsequentOfferFlow
//   // testReceiveSubsequentOfferFlow2
//   // testReceiveSubsequentOfferFlow3
//   // testReceiveSubsequentOfferFlow4
//   // testReceiveSubsequentOfferRequestFlow
//   // testReceiveSubsequentOfferRequestFlow2
//   // testReceiveSubsequentOfferRequestFlow3
//   // testReceiveSubsequentOfferRequestFlow4
//   // testRemoteVersionChangeAfterInitialFlow
//   // testRetransmitAnswer
//   // testRetransmitInitialOffer
//   // testRetransmitInitialOfferRequest
//   // testRetransmitSubsequentOffer
//   // testRetransmitSubsequentOfferRequest
//   // testSetVersion
//   // testStartingSeqNumber
//   // testSubsequentOfferRequestTimeout
//   // testSubsequentOfferTimeout
//   // testSuspension
//   // testTransmitAnswerEmptySDPs
//   // testTransmitDuplicateAnswer
//   // testTransmitDuplicateOffer
//   // testTransmitOfferEmptySDPs
//   // testTransmitOfferRequestWhenWaitingForRxOk
//   // testTransmitOfferWhenWaitingForRxOk
//   // testTransmitSubsequentOfferFlow
//   // testTransmitSubsequentOfferFlow2
//   // testTransmitSubsequentOfferFlow3
//   // testTransmitSubsequentOfferFlow4
//   // testTransmitSubsequentOfferFlowRetry
//   // testTransmitSubsequentOfferRequestFlow
//   // testTransmitSubsequentOfferRequestFlow2
//   // testTransmitSubsequentOfferRequestFlow3
//   // testTransmitSubsequentOfferRequestFlow4
//   // testTransmitSubsequentOfferRequestFlowRetry
});
