/*
 * Copyright 2015 Cisco Systems Inc.
 */

#include "roap_session.h"
using namespace ROAP;

#define ROAP_LOG(args)                                      \
    {                                                       \
        std::ostringstream _roap_log_oss;                   \
        _roap_log_oss << args;                              \
        if (mCallbacks.mLogCallback) {                      \
            mCallbacks.mLogCallback(_roap_log_oss.str());   \
        }                                                   \
    }

std::shared_ptr<RoapSession> RoapSession::create(const std::string& sessionID, CTMS::CThreadContext& context)
{
    return RoapSession::create(sessionID, 0, context);
}

std::shared_ptr<RoapSession> RoapSession::create(const std::string& sessionID,
                                                 uint32_t seq,
                                                 CTMS::CThreadContext& context)
{
    return std::shared_ptr<RoapSession>(new RoapSession(sessionID, seq, context));
}

RoapSession::RoapSession(const std::string& sessionID, uint32_t seq, CTMS::CThreadContext& context) :
    mState(ROAP_STATE_INIT),
    mVersion(roap_version_one),
    mLastSeq(seq), mLocalSessionID(sessionID),
    mUniformDist(1, 0xFFFFFFFE),
    mRetransmitTimer(context.GetIOService()),
    mRetransmitDuration(std::chrono::seconds(5)),
    mTransactionTimeoutTimer(context.GetIOService()),
    mTransactionTimeoutDuration(std::chrono::seconds(90)),
    mContext(context),
    mSuspended(false)
{
    // seed RNG with the current time, the number of seconds we've
    // spent on the CPU, our pid, our uid, and our gid.  this is based
    // on the algorithm described in RFC1889 appendex A.6.  NOTE that
    // we are skipping the unique host id as this can require DNS
    // service to determine (hostname -> IP address mapping for
    // systems without a configured unique host id... see man
    // gethostid)
    mRNG.seed(time(NULL) + clock() + getpid() + getuid() + getgid());
}

RoapSession::~RoapSession()
{
    mRetransmitTimer.cancel();
    mTransactionTimeoutTimer.cancel();
}

static bool isInitState(RoapState s) {
    switch (s) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
        return true;

    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_OK:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        return false;
    }

    // should not get to here
    return false;
}

static bool isRemotePendingState(RoapState s) {
    switch (s) {
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_OK:
        return true;

    case ROAP_STATE_INIT:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        return false;
    }

    // should not get to here
    return false;
}

static bool isKnownVersion(const std::string& version)
{
    if (version == roap_version_one) {
        return true;
    }

    if (version == roap_version_two) {
        return true;
    }

    return false;
}

void RoapSession::receive(const RoapMessage& message)
{
    if (isSuspended()) {
        return;
    }

    if (! message.isValid()) {
        ROAP_LOG("received invalid message\n" << message);
        ++ mReceiveStats["INVALID"];
        return;
    }

    // incr stats
    ++ mReceiveStats[message.mMessageType];

    // if our state is not INIT then validate that session ids are
    // correct and that the sequence number is not old
    if (! isInitState(mState)) {
        if (! validateVersion(message)) {
            ROAP_LOG("unexpected version (expected " << mVersion << ") in rx message\n" << message);

            std::ostringstream oss;
            oss << "unexpected version '" << message.mVersion << "' expected '" << mVersion << "'";
            transmitErrorMessage(message, roap_error_type_refused, oss.str());
            return;
        }

        if (! validateSessionIDs(message)) {
            ROAP_LOG("invalid session ids in rx message\n" << message);

            std::ostringstream oss;
            oss << "received invalid session ids offerer=" << message.mOffererSessionID.get_value_or("None")
                << " answerer=" << message.mAnswererSessionID.get_value_or("None");
            transmitErrorMessage(message, roap_error_type_nomatch, oss.str());
            return;
        }

        if (message.mSeq < mLastSeq) {
            ROAP_LOG("invalid sequence number in rx message\n" << message);
            transmitOOOErrorMessage(message, false);
            return;
        }
    }

    // remember this message was received
    mLastReceiveMessage = message;

    // log that we receive this message
    ROAP_LOG("receive message\n" << message);

    // if a remote session token is set, remember it
    if (message.mSetSessionToken) {
        mRemoteSessionToken = message.mSetSessionToken;
    }

    if (message.mMessageType == roap_message_type_offer_request) {
        receiveOfferRequest(message);
    } else if (message.mMessageType == roap_message_type_offer_response) {
        receiveOfferResponse(message);
    } else if (message.mMessageType == roap_message_type_offer) {
        receiveOffer(message);
    } else if (message.mMessageType == roap_message_type_answer) {
        receiveAnswer(message);
    } else if (message.mMessageType == roap_message_type_ok) {
        receiveOk(message);
    } else if (message.mMessageType == roap_message_type_error) {
        receiveError(message);
    }
}

int RoapSession::transmitOfferRequest(const boost::optional<std::vector<std::string>>& headers)
{
    if (isSuspended()) {
        return 0;
    }

    switch (mState) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_WAIT_RX_OK:
        // valid to send an offer request in these states.  this will
        // be a new transaction.
        //
        // for ROAP_STATE_WAIT_RX_OK, allow transmit of new remote offer request
        // while waiting to receive an ok from previous request
        startNewTransaction(true);
        break;

    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_ERROR:
        return -1;
    }

    if (mState == ROAP_STATE_INIT) {
        // create the initial offer request message to be sent.
        // the remote session id (offerer session id) is not known.
        mLastTransmitOfferRequest = createInitialOfferRequestMessage(mLocalSessionID, mLastSeq);
        mLastTransmitOfferRequest->mHeaders = headers;

        // send out the offer
        transmitMessage(*mLastTransmitOfferRequest);

        // change state
        changeState(ROAP_STATE_INIT_WAIT_RX_OFFER);

    } else {
        // create the non-initial offer request message to be sent.
        // when we are transmitting an offer request, the local
        // session id is the answerer and the remote session id is the
        // offerer
        mLastTransmitOfferRequest = createOfferRequestMessage(mLastSeq, mRemoteSessionID, mLocalSessionID, generateTieBreaker());
        mLastTransmitOfferRequest->mHeaders = headers;

        // send out the offer
        transmitMessage(*mLastTransmitOfferRequest);

        // change state
        changeState(ROAP_STATE_WAIT_RX_OFFER);
    }

    return 0;
}

int RoapSession::transmitOffer(const std::vector<std::string>& sdps, const boost::optional<std::vector<std::string>>& headers)
{
    if (isSuspended()) {
        return 0;
    }

    // SDPs must not be empty
    if (sdps.empty()) {
        return -1;
    }

    switch (mState) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_WAIT_RX_OK:
        // valid to send an offer in these states.  this will be a new
        // transaction;
        //
        // for ROAP_STATE_WAIT_RX_OK, allow transmit of new remote offer
        // while waiting to receive an ok from previous offer
        startNewTransaction(true);
        break;

    case ROAP_STATE_WAIT_TX_OFFER:
        // valid to send an offer in this state.  this will be in
        // response to an offer request so we do not bump the sequence
        // number.
        break;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_ERROR:
        ROAP_LOG("ignoring offer transmit due to current state " << mState << " is not a valid state to transmit offer");
        return -1;
    }

    if (mState == ROAP_STATE_INIT) {
        // create the initial offer message to be sent. the remote session id (answerer
        // session id) is not known.
        mLastTransmitOffer = createInitialOfferMessage(sdps, mLocalSessionID, mLastSeq);
        mLastTransmitOffer->mHeaders = headers;

        // send out the offer
        transmitMessage(*mLastTransmitOffer);

        // change state
        changeState(ROAP_STATE_INIT_WAIT_RX_ANSWER);

    } else {

        RoapState newState = ROAP_STATE_WAIT_RX_ANSWER;
        if (mState == ROAP_STATE_WAIT_TX_OFFER && mVersion != roap_version_one) {
            // after version 1 we use the offer response message to
            // respond to an offer request
            mLastTransmitOffer = createOfferResponseMessage(mLastSeq, sdps);
            newState = ROAP_STATE_WAIT_RX_ANSWER_RESPONSE;

        } else {
            // create the non-initial offer message to be sent.  when we
            // are transmitting an offer, the local session id is the
            // offerer and the remote session id is the answerer
            mLastTransmitOffer = createOfferMessage(mLastSeq, sdps, mLocalSessionID, mRemoteSessionID, generateTieBreaker());
        }

        mLastTransmitOffer->mHeaders = headers;
        mLastTransmitOffer->mResponseToken = mRemoteOfferRequestResponseToken;
        mRemoteOfferRequestResponseToken.reset();

        // send out the offer
        transmitMessage(*mLastTransmitOffer);

        // change state
        changeState(newState);
    }

    return 0;
}

int RoapSession::transmitAnswer(const std::vector<std::string>& sdps, const boost::optional<std::vector<std::string>>& headers)
{
    if (isSuspended()) {
        return 0;
    }

    if (sdps.empty()) {
        return -1;
    }

    if (mState != ROAP_STATE_WAIT_TX_ANSWER) {
        return -1;
    }

    // create the answer message to be sent.  when we are transmitting
    // an answer, the local session id is the answerer and the remote
    // session id is the offerer
    mLastTransmitAnswer = createAnswerMessage(mLastSeq, sdps, mRemoteSessionID, mLocalSessionID);
    mLastTransmitAnswer->mHeaders = headers;
    mLastTransmitAnswer->mResponseToken = mRemoteOfferResponseToken;
    mRemoteOfferResponseToken.reset();

    // send out the answer
    transmitMessage(*mLastTransmitAnswer);

    // change state
    changeState(ROAP_STATE_WAIT_RX_OK);

    return 0;
}

int RoapSession::transmitOk()
{
    if (isSuspended()) {
        return 0;
    }

    if (mState != ROAP_STATE_WAIT_TX_OK) {
        return -1;
    }

    mLastTransmitOk = createOkMessage(mLastSeq, mLocalSessionID, mRemoteSessionID);
    mLastTransmitOk->mResponseToken = mRemoteAnswerResponseToken;
    mRemoteAnswerResponseToken.reset();

    // send out the ok
    transmitMessage(*mLastTransmitOk);

    // change state
    changeState(ROAP_STATE_IDLE_LOCAL_OFFER);

    return 0;
}

int RoapSession::transmitError(const std::string& errorCause)
{
    if (isSuspended()) {
        return 0;
    }

    switch (mState) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_OK:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        return -1;

    case ROAP_STATE_WAIT_TX_OFFER:
        {
            auto rm = createErrorMessage(mLastSeq, mRemoteSessionID, mLocalSessionID, roap_error_type_failed, errorCause);
            rm.mResponseToken = mRemoteOfferRequestResponseToken;
            mRemoteOfferRequestResponseToken.reset();

            transmitMessage(rm);

            // change state back to idle, the current transaction is done
            changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
        }
        break;

    case ROAP_STATE_WAIT_TX_ANSWER:
        {
            auto rm = createErrorMessage(mLastSeq, mRemoteSessionID, mLocalSessionID, roap_error_type_failed, errorCause);
            rm.mResponseToken = mRemoteOfferResponseToken;
            mRemoteOfferResponseToken.reset();

            transmitMessage(rm);

            // change state back to idle, the current transaction is done
            changeState(ROAP_STATE_IDLE_REMOTE_OFFER);
        }
        break;

    case ROAP_STATE_WAIT_TX_OK:
        {
            auto rm = createErrorMessage(mLastSeq, mLocalSessionID, mRemoteSessionID, roap_error_type_failed, errorCause);
            rm.mResponseToken = mRemoteAnswerResponseToken;
            mRemoteAnswerResponseToken.reset();

            transmitMessage(rm);

            // change state back to idle, the current transaction is done
            changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
        }
        break;
    }

    return 0;
}

void RoapSession::registerCallbacks(const RoapSessionCallbacks& callbacks)
{
    mCallbacks = callbacks;
}

RoapState RoapSession::getState() const
{
    return mState;
}

const std::string& RoapSession::getVersion() const
{
    return mVersion;
}

uint32_t RoapSession::getCurrentSeq() const
{
    return mLastSeq;
}

int RoapSession::setVersion(const std::string& version)
{
    switch (mState) {
    case ROAP_STATE_INIT:
        // fall through
        break;

    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_OK:
        // cannot set the version once the session has been
        // initialized
        return -1;
    }

    // only allow known versions
    if (! isKnownVersion(version)) {
        return -1;
    }

    mVersion = version;
    return 0;
}

bool RoapSession::isTransactionInProgress() const {
    switch (mState) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        return false;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_OK:
        return true;
    }

    // should not get to here
    return false;
}

const boost::optional<RoapMessage>& RoapSession::getLastReceiveMessage() const
{
    return mLastReceiveMessage;
}

const roap_message_stats& RoapSession::getReceiveStats() const
{
    return mReceiveStats;
}

const roap_message_stats& RoapSession::getTransmitStats() const
{
    return mTransmitStats;
}

void RoapSession::receiveOfferRequest(const RoapMessage& message)
{
    switch (mState) {
    case ROAP_STATE_INIT:
        // received an offer request while in init state, this is the
        // first thing we have received so it is valid.  remember the
        // version and remote session id from this message.
        mVersion = message.mVersion;
        mRemoteSessionID = message.mAnswererSessionID;
        break;

    case ROAP_STATE_WAIT_TX_OFFER:
        // received an offer request while waiting to send an offer.
        // if the sequence number is the same as the last received
        // offer request then this is a retransmission, ignore it.  if
        // the sequence number is higher, then this is a new event.
        if (message.mSeq == mLastSeq) {
            return;
        }
        break;

    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
        // received an offer request while in idle state, the sequence
        // number must increment.
        if (message.mSeq == mLastSeq) {
            transmitOOOErrorMessage(message, true);
            return;
        }
        break;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_OFFER:
        // received an offer request while we have a pending offer
        // request.  this may be a GLARE condition.  if the sequence
        // number is older than our current sequence number then just
        // send an error back.  if the sequence number is the same as
        // our sequence number, then we have GLARE.  if the sequence
        // number is newer, then perhaps the offer was lost and this
        // is a new transaction.
        if (message.mSeq < mLastSeq) {
            // ooo case.
            transmitOOOErrorMessage(message, false);
            return;

        } else if (message.mSeq == mLastSeq) {
            if (! message.mTieBreaker) {
                // no tie-breaker, this is an error
                transmitErrorMessage(message, roap_error_type_failed, "missing tieBreaker field");
                return;
            }

            // glare case.  compare the tie-breaker in our last offer
            // request with the tie-breaker in this offer request, the
            // higher value wins.
            if (*message.mTieBreaker < *mLastTransmitOfferRequest->mTieBreaker) {
                // we win, send an error and stop processing this offer
                transmitConflictErrorMessage(message, *mLastTransmitOfferRequest);
                return;

            } else if (*message.mTieBreaker == *mLastTransmitOfferRequest->mTieBreaker) {
                // both sides lose, send an error, retransmit our
                // offer request with a new tie breaker.
                ROAP_LOG("glare everyone loses");
                transmitDoubleConflictErrorMessage(message, *mLastTransmitOfferRequest);

                changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
                transmitOfferRequest(mLastTransmitOfferRequest->mHeaders);
                return;

            } else {
                // we lose, process this offer request
                ROAP_LOG("glare we lose");
            }

        } else {
            // new transaction, we never got the offer we wanted but
            // let's just pretend like that didn't happen.
            ROAP_LOG("glare we lose, remote has higher seqnum");
        }
        break;

    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER:
        // received an offer request while we have a pending offer.
        // this may be a GLARE condition.  if the sequence number is
        // older then just send an error back.
        if (message.mSeq < mLastSeq) {
            // ooo case.
            transmitOOOErrorMessage(message, false);
            return;
        }

        if (message.mSeq == mLastSeq) {
            // if this is version one then just retransmit our pending offer
            if (mVersion == roap_version_one) {
                mLastSeq = message.mSeq;
                mRemoteOfferRequestResponseToken = message.mSetResponseToken;
                changeState(ROAP_STATE_WAIT_TX_OFFER);
                transmitOffer(*mLastTransmitOffer->mSdps, mLastTransmitOffer->mHeaders);
                return;
            }

            if (! message.mTieBreaker) {
                // no tie-breaker, this is an error
                transmitErrorMessage(message, roap_error_type_failed, "missing tieBreaker field");
                return;
            }

            // glare case.  compare the tie-breaker in our last offer
            // with the tie-breaker in this offer request, the higher
            // value wins.
            if (*message.mTieBreaker < *mLastTransmitOffer->mTieBreaker) {
                // we win, send an error and stop processing this offer request
                transmitConflictErrorMessage(message, *mLastTransmitOffer);
                return;

            } else if (*message.mTieBreaker == *mLastTransmitOffer->mTieBreaker) {
                // both sides lose, send an error, retransmit our
                // offer with a new tie breaker.
                ROAP_LOG("glare everyone loses");
                transmitDoubleConflictErrorMessage(message, *mLastTransmitOffer);

                changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
                transmitOffer(*mLastTransmitOffer->mSdps, mLastTransmitOffer->mHeaders);
                return;

            } else {
                // we lose, process this offer request
                ROAP_LOG("glare we lose");
            }

        } else {
            // new transaction, we never got the offer we wanted but
            // let's just pretend like that didn't happen.
            ROAP_LOG("glare we lose, remote has higher seqnum");
        }
        break;

    case ROAP_STATE_WAIT_RX_OK:
        // received a remote offer request while waiting for an ok.
        // if this is not a new request, then return an error.  if
        // this is a new request, then assume the ok was lost (trigger
        // a fake callback), then fall through to process the new
        // offer request.
        if (message.mSeq == mLastSeq) {
            transmitInvalidStateErrorMessage(message);
            return;
        } else {
            if (mCallbacks.mReceiveOkCallback) {
                mCallbacks.mReceiveOkCallback();
            }
        }
        break;
    case ROAP_STATE_WAIT_TX_OK:
        // received a remote offer request while waiting to send an ok.
        // if this is not a new request, then return an error. if
        // this is a new request, then assume the other side don't want the ok
        // then fall through to process the new offer request.
        if (message.mSeq == mLastSeq) {
            transmitInvalidStateErrorMessage(message);
            return;
        }
        // if we get to here, this is a new offer request. assuming the other
        // side doesn't want the ok; just proceed with this new offer request.
        break;

    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_ERROR:
        // invalid state to receive this message in
        transmitInvalidStateErrorMessage(message);
        return;
    }

    // a valid offer request has been received.  remember the sequence
    // number, change state, and fire the callback
    mLastSeq = message.mSeq;
    mRemoteOfferRequestResponseToken = message.mSetResponseToken;
    changeState(ROAP_STATE_WAIT_TX_OFFER);

    // this is a new transaction
    startNewTransaction(false);

    if (mCallbacks.mReceiveOfferRequestCallback) {
        mCallbacks.mReceiveOfferRequestCallback();
    }
}

void RoapSession::receiveOffer(const RoapMessage& message)
{
    switch (mState) {
    case ROAP_STATE_INIT:
        // received an offer while in init state, this is the first
        // thing we have received so it is valid.  remember the
        // version and remote session id from this message.
        mVersion = message.mVersion;
        mRemoteSessionID = message.mOffererSessionID;
        break;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
        // received an offer while waiting to receive the first
        // message from the remote side.  make sure the sequence
        // number is correct and remember the remote session id from
        // this message.
        if (message.mSeq < mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        mRemoteSessionID = message.mOffererSessionID;
        break;

    case ROAP_STATE_WAIT_TX_ANSWER:
        // received a remote offer while waiting to send an answer.
        // if this is a retransmission then ignore it, otherwise
        // process normally.
        if (message.mSeq == mLastSeq) {
            // retransmission, ignore
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_OK:
        // received a remote offer while waiting for an ok.  if this
        // is a retransmission then send our last answer again,
        // otherwise process normally.  this might happen if the
        // remote side received our answer but did not send an ok (or
        // the ok got lost).
        if (message.mSeq == mLastSeq) {
            // retransmission, retransmit last answer
            transmitMessage(*mLastTransmitAnswer);
            return;
        } else {
            // this is a new offer, the ok may have been lost.  fake
            // reception of the OK, then fall through to process the
            // new offer.
            if (mCallbacks.mReceiveOkCallback) {
                mCallbacks.mReceiveOkCallback();
            }
        }
        break;
    case ROAP_STATE_WAIT_TX_OK:
        // received a remote offer while waiting to send an ok.
        // if this is not a new request, then return an error. if
        // this is a new request, then assume the other side don't want the ok
        // then fall through to process the new offer.
        if (message.mSeq == mLastSeq) {
            transmitInvalidStateErrorMessage(message);
            return;
        }
        // if we get to here, this is a new offer. assuming the other
        // side doesn't want the ok; just proceed with this new offer.
        break;

    case ROAP_STATE_WAIT_RX_OFFER:
        // received a remote offer while waiting for an offer.  check
        // that the sequence number is the expected sequence number.
        if (message.mSeq < mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        break;

    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER:
        // received a remote offer while we have a pending offer.
        // this may be a GLARE condition.  if the sequence number is
        // older than our current sequence number then just send an
        // error back.  if the sequence number is the same as our
        // sequence number, then we have GLARE.  if the sequence
        // number is newer, then perhaps the answer was lost and this
        // is a new transaction.
        if (message.mSeq < mLastSeq) {
            // ooo case.
            transmitOOOErrorMessage(message, false);
            return;

        } else if (message.mSeq == mLastSeq) {
            if (! message.mTieBreaker) {
                // no tie-breaker, this is an error
                transmitErrorMessage(message, roap_error_type_failed, "missing tieBreaker field");
                return;
            }

            // glare case.  compare the tie-breaker is our last offer
            // with the tie-breaker in this offer, the higher value
            // wins.
            if (*message.mTieBreaker < *mLastTransmitOffer->mTieBreaker) {
                // we win, send an error and stop processing this offer
                ROAP_LOG("glare but we win");
                transmitConflictErrorMessage(message, *mLastTransmitOffer);
                return;

            } else if (*message.mTieBreaker == *mLastTransmitOffer->mTieBreaker) {
                // both sides lose, send an error, retransmit our
                // offer with a new tie breaker.
                ROAP_LOG("glare everyone loses");
                transmitDoubleConflictErrorMessage(message, *mLastTransmitOffer);

                changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
                transmitOffer(*mLastTransmitOffer->mSdps, mLastTransmitOffer->mHeaders);
                return;

            } else {
                // we lose, process this offer
                ROAP_LOG("glare we lose");
            }

        } else {
            // new transaction, we never got the answer we wanted but
            // let's just pretend like that didn't happen.  the new
            // offer's data is more recent than the expected answer
            // anyways.
            ROAP_LOG("glare we lose, remote has higher seqnum");
        }
        break;

    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_ERROR:
        // invalid state to receive this message in
        transmitInvalidStateErrorMessage(message);
        return;

    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
        // received an offer while in idle state, the sequence number
        // must increment.
        if (message.mSeq == mLastSeq) {
            transmitOOOErrorMessage(message, true);
            return;
        }
        break;
    }

    // a valid offer has been received.  remember the sequence number,
    // change state, and fire the callback
    mLastSeq = message.mSeq;
    mRemoteOfferResponseToken = message.mSetResponseToken;
    changeState(ROAP_STATE_WAIT_TX_ANSWER);

    // this is a new transaction, start transaction timeout timer too
    startNewTransaction(false);

    if (mCallbacks.mReceiveOfferCallback) {
        mCallbacks.mReceiveOfferCallback(*message.mSdps);
    }
}

void RoapSession::receiveOfferResponse(const RoapMessage& message)
{
    switch (mState) {
    case ROAP_STATE_INIT:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_ERROR:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
        // invalid state to receive this message in
        transmitInvalidStateErrorMessage(message);
        return;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_OFFER:
        // received a remote offer while waiting for an offer.  check
        // that the sequence number is the expected sequence number.
        if (message.mSeq < mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        break;

    case ROAP_STATE_WAIT_TX_ANSWER:
        // received a remote offer response while waiting to send an
        // answer.  if this is a retransmission then ignore it,
        // otherwise process normally.
        if (message.mSeq == mLastSeq) {
            // retransmission, ignore
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_OK:
        // received a remote offer response while waiting for an ok.
        // if this is a retransmission then send our last answer
        // again, otherwise process normally.  this might happen if
        // the remote side did not receive our answer.
        if (message.mSeq == mLastSeq) {
            // retransmission, retransmit last answer
            transmitMessage(*mLastTransmitAnswer);
            return;
        }
        break;
    }

    // a valid offer has been received.  remember the sequence number,
    // change state, and fire the callback
    mLastSeq = message.mSeq;
    mRemoteOfferResponseToken = message.mSetResponseToken;
    changeState(ROAP_STATE_WAIT_TX_ANSWER);

    if (mCallbacks.mReceiveOfferCallback) {
        mCallbacks.mReceiveOfferCallback(*message.mSdps);
    }
}

void RoapSession::receiveAnswer(const RoapMessage& message)
{
    switch (mState) {
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
        // received answer must have the same sequence number as what
        // we are expecting.  this is the first message we have
        // received from the remote side so remember the remote
        // session id.
        if (message.mSeq != mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        mRemoteSessionID = message.mAnswererSessionID;
        break;

    case ROAP_STATE_WAIT_TX_OK:
        // received an answer while waiting to send an OK.  if this is
        // a retransmission then ignore it.  otherwise send an invalid
        // state error.
        if (message.mSeq == mLastSeq) {
            return;
        } else {
            transmitInvalidStateErrorMessage(message);
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_RX_ANSWER:
        // received answer must have the same sequence number as what
        // we are expecting
        if (message.mSeq != mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        break;

    case ROAP_STATE_IDLE_LOCAL_OFFER:
        // this could be a re-transmission of a previous answer trying
        // to get an OK message.
        // retransmit ok only if we sent an ok previously
        // otherwise let the answer proceed
        if (message.mSeq == mLastSeq && mLastTransmitOk) {
            transmitMessage(*mLastTransmitOk);
            return;
        }
        break;

    case ROAP_STATE_INIT:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_OK:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        // invalid state to receive this message in
        transmitInvalidStateErrorMessage(message);
        return;
    }

    // a valid answer has been received.  change state and fire the
    // callback.
    mRemoteAnswerResponseToken = message.mSetResponseToken;
    changeState(ROAP_STATE_WAIT_TX_OK);

    if (mCallbacks.mReceiveAnswerCallback) {
        mCallbacks.mReceiveAnswerCallback(*message.mSdps);
    }
}

void RoapSession::receiveOk(const RoapMessage& message)
{
    switch (mState) {
    case ROAP_STATE_WAIT_RX_OK:
        // make sure sequence number is correct.  if it is then fall
        // through.
        if (message.mSeq < mLastSeq) {
            transmitOOOErrorMessage(message, false);
            return;
        }
        break;

    case ROAP_STATE_IDLE_REMOTE_OFFER:
        // could just be a retransmission, if sequence number is
        // valid then just ignore it
        if (message.mSeq <= mLastSeq) {
            return;
        }
        break;

    case ROAP_STATE_INIT:
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_ERROR:
        // invalid state to receive this message in
        transmitInvalidStateErrorMessage(message);
        return;
    }

    // valid ok received, change state and invoke callback
    changeState(ROAP_STATE_IDLE_REMOTE_OFFER);

    if (mCallbacks.mReceiveOkCallback) {
        mCallbacks.mReceiveOkCallback();
    }
}

void RoapSession::receiveError(const RoapMessage& message)
{

    switch (mState) {
    case ROAP_STATE_ERROR:
        // already in error state, can't really be more errored
        return;

    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
        // make sure sequence number is correct.  if it is then fall
        // through.  if it is not then just ignore the error.
        if (message.mSeq < mLastSeq) {
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_OFFER:
        // make sure sequence number is correct.  if it is not then
        // just ignore the error.
        if (message.mSeq < mLastSeq) {
            return;
        }

        if (message.mErrorType == roap_error_type_retry) {
            // we sent an offer request, received a retry error.
            // trigger a new offer request.
            ROAP_LOG("received " << roap_error_type_retry << " error, resending last offer request");
            changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
            transmitOfferRequest(mLastTransmitOfferRequest->mHeaders);
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_ANSWER:
        // make sure sequence number is correct.  if it is not then
        // just ignore the error.
        if (message.mSeq < mLastSeq) {
            return;
        }

        if (message.mErrorType == roap_error_type_retry) {
            // we sent an offer, received a retry error.  trigger a
            // new offer.
            ROAP_LOG("received " << roap_error_type_retry << " error, resending last offer");
            changeState(ROAP_STATE_IDLE_LOCAL_OFFER);
            transmitOffer(*mLastTransmitOffer->mSdps, mLastTransmitOffer->mHeaders);
            return;
        } else if (message.mErrorType == roap_error_type_conflict) {
            // we lost a glare condition at some point, ignore this error
            return;
        }
        break;

    case ROAP_STATE_WAIT_RX_OK:
        // make sure sequence number is correct.  if it is then fall
        // through.  if it is not then just ignore the error.
        if (message.mSeq < mLastSeq) {
            return;
        }

        // if the error cause was conflict, then ignore the error message
        if (message.mErrorType == roap_error_type_conflict) {
            return;
        }
        break;

    case ROAP_STATE_INIT:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
        // invalid state to receive this message in, just ignore it
        return;
    }

    // error message was received, tell the user.  not really possible
    // to recover from this, so move into error state and invoke callback.
    changeState(ROAP_STATE_ERROR);

    if (mCallbacks.mReceiveErrorCallback) {
        mCallbacks.mReceiveErrorCallback();
    }
}

void RoapSession::transmitOOOErrorMessage(const RoapMessage& source, bool expectedNew)
{
    auto expectedSeq = (expectedNew ? (mLastSeq + 1) : mLastSeq);
    // don't response to ooo with ooo
    if (source.mMessageType == roap_message_type_error && source.mErrorType && *source.mErrorType == roap_error_type_ooo) {
        ROAP_LOG("ignoring ooo message\n" << source);
    } else {
        std::ostringstream oss;
        oss << "received seq " << source.mSeq << " expected at least " << expectedSeq;
        transmitErrorMessage(source, roap_error_type_ooo, oss.str());
    }
}

void RoapSession::transmitConflictErrorMessage(const RoapMessage& source, const RoapMessage& last)
{
    std::ostringstream oss;
    oss << "detected winning glare condition remoteTieBreaker=" << source.mTieBreaker.get_value_or(0)
        << " localTieBreaker=" << last.mTieBreaker.get_value_or(0);
    transmitErrorMessage(source, roap_error_type_conflict, oss.str());
}

void RoapSession::transmitDoubleConflictErrorMessage(const RoapMessage& source, const RoapMessage& last)
{
    std::ostringstream oss;
    oss << "detected tying glare condition remoteTieBreaker=" << source.mTieBreaker.get_value_or(0)
        << " localTieBreaker=" << last.mTieBreaker.get_value_or(0);
    transmitErrorMessage(source, roap_error_type_double_conflict, oss.str());
}

void RoapSession::transmitInvalidStateErrorMessage(const RoapMessage& source)
{
    std::ostringstream oss;
    oss << "received invalid message type '" << source.mMessageType << "' in state '" << mState << "'";
    transmitErrorMessage(source, roap_error_type_invalid_state, oss.str());
}

void RoapSession::transmitErrorMessage(const RoapMessage& source, const std::string& errorType, const std::string& errorCause)
{
    auto error = createErrorMessage(source.mSeq, source.mOffererSessionID, source.mAnswererSessionID, errorType, errorCause);
    transmitMessage(source, error);
}

void RoapSession::transmitMessage(const RoapMessage& source, RoapMessage& rm)
{
    rm.mResponseToken = source.mSetResponseToken;
    transmitMessage(rm);
}

void RoapSession::transmitMessage(RoapMessage& rm)
{
    rm.mVersion = mVersion;

    if (mVersion == roap_version_one) {
        // set fields only present in version 1
        rm.mSessionToken = mRemoteSessionToken;
    } else {
        // clear fields not supported in higher versions
        rm.mOffererSessionID = boost::none;
        rm.mAnswererSessionID = boost::none;
        rm.mSessionToken = boost::none;
        rm.mResponseToken = boost::none;
    }

    ++ mTransmitStats[rm.mMessageType];
    ROAP_LOG("transmit message\n" << rm);

    if (mCallbacks.mTransmitCallback) {
        mCallbacks.mTransmitCallback(rm);
    }
}

bool RoapSession::validateVersion(const RoapMessage& message)
{
    return (message.mVersion == mVersion);
}

bool RoapSession::validateSessionIDs(const RoapMessage& message)
{
    // only version 1 requires session IDs.  for all other versions
    // just return ok
    if (message.mVersion != roap_version_one) {
        return true;
    }

    // offerer/answerer versus local/remote changes depending on the
    // message type, just validate that they match one way or the
    // other.
    if (message.mOffererSessionID == mLocalSessionID && message.mAnswererSessionID == mRemoteSessionID) {
        return true;
    }

    if (message.mOffererSessionID == mRemoteSessionID && message.mAnswererSessionID == mLocalSessionID) {
        return true;
    }

    return false;
}

void RoapSession::changeState(RoapState state)
{
    ROAP_LOG("changing state from " << mState << " to " << state);
    mState = state;
}

uint32_t RoapSession::generateTieBreaker()
{
    return mUniformDist(mRNG);
}

void RoapSession::setRetransmitDuration(const std::chrono::steady_clock::duration& duration)
{
    mRetransmitDuration = duration;
}

void RoapSession::setTransactionTimeoutDuration(const std::chrono::steady_clock::duration& duration)
{
    mTransactionTimeoutDuration = duration;
}

void RoapSession::setSuspensionState(bool suspended)
{
    mSuspended = suspended;
}

bool RoapSession::isSuspended()
{
    return mSuspended;
}

void RoapSession::startNewTransaction(bool isLocal)
{
    // a new transaction is being started, if locally initiated bump
    // up the sequence number.
    if (isLocal) {
        ++mLastSeq;
    }

    // schedule timers for retransmission and transaction timeout
    scheduleRetransmitTimer();
    scheduleTransactionTimeoutTimer();
}

void RoapSession::scheduleRetransmitTimer()
{
    std::weak_ptr<RoapSession> weak = shared_from_this();
    mRetransmitTimer.cancel();
    mRetransmitTimer.expires_from_now(mRetransmitDuration);
    mRetransmitTimer.async_wait([=](const boost::system::error_code& error) {
            if (error != boost::asio::error::operation_aborted) {
                auto shared = weak.lock();
                if (shared != NULL) {
                    shared->processRetransmitTimer();
                }
            }
        });
}

void RoapSession::processRetransmitTimer()
{
    switch (mState) {
    case ROAP_STATE_INIT_WAIT_RX_OFFER:
    case ROAP_STATE_WAIT_RX_OFFER:
        // timer popped and we are waiting on an offer from the remote
        // side.  our offer request may have been lost, so send it
        // again.
        transmitMessage(*mLastTransmitOfferRequest);
        break;

    case ROAP_STATE_INIT_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER:
    case ROAP_STATE_WAIT_RX_ANSWER_RESPONSE:
        // timer popped and we are waiting on an answer from the
        // remote side.  our offer may have been lost, so send it
        // again.
        transmitMessage(*mLastTransmitOffer);
        break;

    case ROAP_STATE_WAIT_RX_OK:
        // timer popped and we are waiting on an ok from the remote
        // side.  our answer may have been lost, so send it again.
        transmitMessage(*mLastTransmitAnswer);
        break;

    case ROAP_STATE_INIT:
    case ROAP_STATE_WAIT_TX_OFFER:
    case ROAP_STATE_WAIT_TX_ANSWER:
    case ROAP_STATE_WAIT_TX_OK:
    case ROAP_STATE_IDLE_LOCAL_OFFER:
    case ROAP_STATE_IDLE_REMOTE_OFFER:
    case ROAP_STATE_ERROR:
        // not expecting timers in any of these states.  if the timer
        // pops, just ignore it.
        return;
    }

    // reschedule our timer
    scheduleRetransmitTimer();
}

void RoapSession::scheduleTransactionTimeoutTimer()
{
    std::weak_ptr<RoapSession> weak = shared_from_this();
    mTransactionTimeoutTimer.cancel();
    mTransactionTimeoutTimer.expires_from_now(mTransactionTimeoutDuration);
    mTransactionTimeoutTimer.async_wait([=](const boost::system::error_code& error) {
            if (error != boost::asio::error::operation_aborted) {
                auto shared = weak.lock();
                if (shared != NULL) {
                    shared->processTransactionTimeoutTimer();
                }
            }
        });
}

void RoapSession::processTransactionTimeoutTimer()
{
    if (isRemotePendingState(mState)) {
        // timer popped and we are still waiting on some message from remote side
        // time to give up and fire a timeout callback.
        if (mCallbacks.mTransactionTimeoutCallback) {
            mCallbacks.mTransactionTimeoutCallback();
        }
    }
    // not expecting timers in any other states. if the timer pops, just ignore it.
}
