import fromObject, {
  RoapMessage,
  AnswerMessage,
  ErrorMessage,
  OfferMessage,
  OfferRequestMessage,
  OfferResponseMessage,
  OkMessage
} from './messages';

/**
 * Single transaction state machine for roap message passing
 */
export default class RoapTransaction {
  static createFromLocalOffer(seq, sdp) {
    const tx = new RoapTransaction(seq);
    tx.transmitOffer(sdp);
    return tx;
  }

  static createFromRemoteOffer(msg) {
    const tx = new RoapTransaction(msg.seq);
    tx.receive(msg);
    return tx;
  }

  /**
   * Represents the states of the current transaction
   * @enum
   */
  static State = {
    INIT_WAIT_RX_OFFER: 'INIT_WAIT_RX_OFFER',
    INIT_WAIT_RX_ANSWER: 'INIT_WAIT_RX_ANSWER',
    WAIT_TX_OFFER: 'WAIT_TX_OFFER',
    WAIT_TX_ANSWER: 'WAIT_TX_ANSWER',
    WAIT_TX_OK: 'WAIT_TX_OK',
    WAIT_RX_OFFER: 'WAIT_RX_OFFER',
    WAIT_RX_ANSWER: 'WAIT_RX_ANSWER',
    WAIT_RX_ANSWER_RESPONSE: 'WAIT_RX_ANSWER_RESPONSE',
    WAIT_RX_OK: 'WAIT_RX_OK'
  }

  seq = 1

  constructor(seq = 1) {

  }

  transmitAnswer(sdp) {

  }

  transmiteOffer(sdp) {

  }

  transmitOfferResponse(sdp) {

  }

  /**
   * Sends a RoapMessage
   * @param {RoapMessage} msg
   * @private
   */
  transmit(msg) {
    switch (this.state) {
      case RoapTransaction.State.INIT:
        // message must be one of Offer or OfferRequest
        break;
      case RoapTransaction.State.WAIT_TX:
        // message must be one of OfferResponse, Answer, OK
        break;
      case RoapTransaction.State.WAIT_RX:
        // may only resubmit
        break;
      case RoapTransaction.State.IDLE:
        // invalid
        break;
      case RoapTransaction.State.ERROR:
        // invalid? or possibly only errors
        break;
      default:
        throw new Error('Unreachable code reached');
    }
  }

  /**
   * Receive an incoming RoapMessage determine if it's valid for this
   * transaction, and respond appropriately
   * @param {Object|RoapMessage} raw
   *
   */
  receive(raw) {

  }
}
