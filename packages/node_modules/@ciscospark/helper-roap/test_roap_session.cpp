/**
 * Copyright 2015-2016, Cisco Systems Inc.
 */

#include <boost/optional/optional_io.hpp>

#include "LogMacros.h"
#include "roap_session.h"
using namespace ROAP;

#include <cppunit/TestCaller.h>
#include <cppunit/TestFixture.h>
#include <cppunit/extensions/HelperMacros.h>

static const std::string localSessionID("localSessionID");
static const std::string remoteSessionID("remoteSessionID");
static const std::string sessionToken("sessionToken");

class TestRoapSession : public CppUnit::TestFixture {
public:
    std::vector<RoapMessage> transmitMessages;
    std::size_t receiveOfferRequestCount;
    std::vector<std::vector<std::string>> receiveOfferSdps;
    std::vector<std::vector<std::string>> receiveAnswerSdps;
    std::size_t receiveOkCount;
    std::size_t receiveErrorCount;
    std::size_t timeoutCount;
    std::string responseToken;
    std::string version;

    CTMS::CThreadContext context;
    std::shared_ptr<RoapSession> rs;

    void setUp() {
        initData();

        responseToken = "r";
        version = roap_version_one;

        createRoapSession();
    }

    void tearDown() {
        rs.reset();
    }

    void initData() {
        // reset all counters and stored data
        transmitMessages.clear();
        receiveOfferRequestCount = 0;
        receiveOfferSdps.clear();
        receiveAnswerSdps.clear();
        receiveOkCount = 0;
        receiveErrorCount = 0;
    }

    void createRoapSession(boost::optional<uint32_t> optSeq = boost::none) {
        RoapSessionCallbacks callbacks;
        callbacks.mTransmitCallback = [&](const RoapMessage& rm) { transmitMessages.push_back(rm); };
        callbacks.mLogCallback = [](const std::string& s) { SLOG_INFO(s); };
        callbacks.mReceiveOfferRequestCallback = [&]() { ++receiveOfferRequestCount; };
        callbacks.mReceiveOfferCallback = [&](const std::vector<std::string>& sdps) { receiveOfferSdps.push_back(sdps); };
        callbacks.mReceiveAnswerCallback = [&](const std::vector<std::string>& sdps){ receiveAnswerSdps.push_back(sdps); };
        callbacks.mReceiveOkCallback = [&](){ ++receiveOkCount; };
        callbacks.mReceiveErrorCallback = [&](){ ++receiveErrorCount; };
        callbacks.mTransactionTimeoutCallback = [&](){ ++timeoutCount; };

        if (optSeq) {
            rs = RoapSession::create(localSessionID, *optSeq, context);
        } else {
            rs = RoapSession::create(localSessionID, context);
        }
        rs->registerCallbacks(callbacks);
    }

    void testDefaultState() {
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT, rs->getState());
        CPPUNIT_ASSERT(! rs->isTransactionInProgress());
    }

    void doTriggerReceiveValid(RoapMessage rm)
    {
        responseToken += "r";

        rm.mVersion = version;
        rm.mSetSessionToken = sessionToken;
        rm.mSetResponseToken = responseToken;
        rs->receive(rm);
    }

    void validateOfferRequestMessage(const RoapMessage& rm,
                                     uint32_t seq,
                                     const boost::optional<std::string>& offererSessionID,
                                     const boost::optional<std::string>& answererSessionID)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_offer_request, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT_EQUAL(offererSessionID, rm.mOffererSessionID);

        CPPUNIT_ASSERT_EQUAL(answererSessionID, rm.mAnswererSessionID);

        CPPUNIT_ASSERT(!rm.mHeaders);
    }

    void validateOfferMessage(const RoapMessage& rm,
                              uint32_t seq,
                              const boost::optional<std::string>& offererSessionID,
                              const boost::optional<std::string>& answererSessionID,
                              const std::vector<std::string>& sdps,
                              bool isResponse)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_offer, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT_EQUAL(offererSessionID, rm.mOffererSessionID);

        CPPUNIT_ASSERT_EQUAL(answererSessionID, rm.mAnswererSessionID);

        CPPUNIT_ASSERT(rm.mSdps);
        CPPUNIT_ASSERT(sdps == *rm.mSdps);

        if (isResponse) {
            CPPUNIT_ASSERT(rm.mResponseToken);
            CPPUNIT_ASSERT_EQUAL(responseToken, *rm.mResponseToken);
        } else {
            CPPUNIT_ASSERT(!rm.mResponseToken);
        }

        CPPUNIT_ASSERT(!rm.mHeaders);
    }

    void validateOfferResponseMessage(const RoapMessage& rm, uint32_t seq, const std::vector<std::string>& sdps)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_offer_response, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT(! rm.mOffererSessionID);
        CPPUNIT_ASSERT(! rm.mAnswererSessionID);

        CPPUNIT_ASSERT(rm.mSdps);
        CPPUNIT_ASSERT(sdps == *rm.mSdps);

        CPPUNIT_ASSERT(!rm.mResponseToken);
        CPPUNIT_ASSERT(!rm.mHeaders);
    }

    void validateAnswerMessage(const RoapMessage& rm, uint32_t seq, const boost::optional<std::string>& offererSessionID,
                               const boost::optional<std::string>& answererSessionID, const std::vector<std::string>& sdps)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_answer, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT_EQUAL(offererSessionID, rm.mOffererSessionID);

        CPPUNIT_ASSERT_EQUAL(answererSessionID, rm.mAnswererSessionID);

        CPPUNIT_ASSERT(rm.mSdps);
        CPPUNIT_ASSERT(sdps == *rm.mSdps);

        if (version == roap_version_one) {
            CPPUNIT_ASSERT(rm.mResponseToken);
            CPPUNIT_ASSERT_EQUAL(responseToken, *rm.mResponseToken);
        } else {
            CPPUNIT_ASSERT(!rm.mResponseToken);
        }

        CPPUNIT_ASSERT(!rm.mHeaders);
    }

    void validateOkMessage(const RoapMessage& rm,
                           uint32_t seq,
                           const boost::optional<std::string>& offererSessionID,
                           const boost::optional<std::string>& answererSessionID)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_ok, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT_EQUAL(offererSessionID, rm.mOffererSessionID);

        CPPUNIT_ASSERT_EQUAL(answererSessionID, rm.mAnswererSessionID);

        if (version == roap_version_one) {
            CPPUNIT_ASSERT(rm.mResponseToken);
            CPPUNIT_ASSERT_EQUAL(responseToken, *rm.mResponseToken);
        } else {
            CPPUNIT_ASSERT(!rm.mResponseToken);
        }
    }

    void validateErrorMessage(const RoapMessage& rm, uint32_t seq, const std::string& offererSessionID,
                              const boost::optional<std::string>& answererSessionID, const std::string& errorType)
    {
        CPPUNIT_ASSERT(rm.isValid());
        CPPUNIT_ASSERT_EQUAL(version, rm.mVersion);
        CPPUNIT_ASSERT_EQUAL(roap_message_type_error, rm.mMessageType);
        CPPUNIT_ASSERT_EQUAL(seq, rm.mSeq);

        CPPUNIT_ASSERT(rm.mOffererSessionID);
        CPPUNIT_ASSERT_EQUAL(offererSessionID, *rm.mOffererSessionID);

        CPPUNIT_ASSERT_EQUAL(rm.mAnswererSessionID.is_initialized(), answererSessionID.is_initialized());
        if(answererSessionID.is_initialized()) {
            CPPUNIT_ASSERT_EQUAL(*answererSessionID, *rm.mAnswererSessionID);
        }

        CPPUNIT_ASSERT(rm.mResponseToken);
        CPPUNIT_ASSERT_EQUAL(responseToken, *rm.mResponseToken);

        CPPUNIT_ASSERT(rm.mErrorType);
        CPPUNIT_ASSERT_EQUAL(errorType, *rm.mErrorType);
    }

    void doInitialReceiveOfferRequestFlow(bool sendOk=true) {
        // trigger receive of an initial offer request
        doTriggerReceiveValid(createInitialOfferRequestMessage(remoteSessionID));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, sdps, true);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        if (sendOk) {
            // trigger transmission of an ok
            CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

            // should invoke the transmit callback with an ok message
            CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
            validateOkMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID);

            // state should be correct
            CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        }

        CPPUNIT_ASSERT_EQUAL(!rs->isTransactionInProgress(), sendOk);
    }

    void testInitialReceiveOfferRequestFlow() {
        doInitialReceiveOfferRequestFlow();
    }

    void testInitialReceiveOfferRequestFlowVersionTwo() {
        // set expected version
        version = roap_version_two;

        // trigger receive of an initial offer request
        doTriggerReceiveValid(createInitialOfferRequestMessage(boost::none));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer response message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferResponseMessage(transmitMessages.back(), 1, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER_RESPONSE, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, boost::none, boost::none));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 1, boost::none, boost::none);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialReceiveOfferRequestFlowVersionThree() {
        // trigger receive of an initial offer request
        doTriggerReceiveValid(createOfferRequestMessage(10, localSessionID, remoteSessionID, 0));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 10, localSessionID, remoteSessionID, sdps, true);

        // state should be correctj
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // resend offer message
        doTriggerReceiveValid(createOfferRequestMessage(8, localSessionID, remoteSessionID, 0));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // should invoke the transmit callback with out of bandwidth (OOO) message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 8, localSessionID, remoteSessionID, roap_error_type_ooo);
    }

    void testInitialReceiveOfferFlow() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialReceiveOfferFlowVersionTwo() {
        // expected version
        version = roap_version_two;

        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, boost::none));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, boost::none, boost::none, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, boost::none, boost::none));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialReceiveOfferFlowDuplicateOk() {
        // set things up
        testInitialReceiveOfferFlow();

        // remember this
        auto preSize = transmitMessages.size();

        // send in another (duplicate) ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should not send out an error message (or any other message)
        CPPUNIT_ASSERT_EQUAL(preSize, transmitMessages.size());
    }

    void testInitialReceiveBadOffer() {
        // trigger receive of an initial offer request with a bad Version
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createInitialOfferMessage(sdps, remoteSessionID);
        // Intentionally insert bad version in message
        offerMessage.mVersion = "0";
        rs->receive(offerMessage);

        // Since there was a bad message version, should NOT have invoked
        // callback to process received offer.
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());
    }

    void testInitialTransmitOfferRequestFlow() {
        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(transmitMessages.back().mSeq, sdps, remoteSessionID, localSessionID, 0));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialTransmitOfferRequestFlowVersionTwo() {
        // expected version
        version = roap_version_two;
        CPPUNIT_ASSERT_EQUAL( 0, rs->setVersion(version) );

        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, boost::none);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an offer response
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferResponseMessage(transmitMessages.back().mSeq, sdps));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, boost::none, boost::none, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, boost::none, boost::none));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialTransmitDuplicateOfferRequest() {
        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // try transmitting a duplicate offer request.
        // this should be be rejected since we are in INIT_WAIT_RX_ANSWER
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOfferRequest(boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
    }

    void testInitialTransmitOfferFlow() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialTransmitOfferFlowVersionTwo() {
        // expected version
        version = roap_version_two;
        CPPUNIT_ASSERT_EQUAL( 0, rs->setVersion(version) );

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, boost::none, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, boost::none, boost::none));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 1, boost::none, boost::none);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testInitialTransmitOfferFlowStats() {
        testInitialTransmitOfferFlow();

        auto receiveStats = rs->getReceiveStats();
        auto transmitStats = rs->getTransmitStats();

        // Verify stats (message counts) from testInitialTransmitOfferFlow()
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), receiveStats[roap_message_type_answer]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), transmitStats[roap_message_type_offer]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), transmitStats[roap_message_type_ok]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(0), transmitStats[roap_message_type_answer]);
    }

    void testInitialTransmitDuplicateOffer() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // try transmitting a duplicate offer.
        // this should be be rejected since we are in INIT_WAIT_RX_ANSWER
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOffer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
    }

    void testInitialTransmitOfferWithDuplicateOk() {
        // do transmit offer flow and store how many messages have been transmitted
        testInitialTransmitOfferFlow();
        auto previousTransmitCount(transmitMessages.size());

        // try transmitting a duplicate Ok message.
        // since in IDLE_LOCAL_OFFER, duplicate transmit of OK should be rejected
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOk());
        CPPUNIT_ASSERT_EQUAL(previousTransmitCount, transmitMessages.size());
    }

    void testInitialTransmitOfferWithErrorMessage() {
        // do transmit offer flow and store how many messages have been transmitted
        testInitialTransmitOfferFlow();
        auto previousTransmitCount(transmitMessages.size());

        // try transmitting an error message.
        // since in IDLE_LOCAL_OFFER, transmit of error should be rejected
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitError("Test Error Msg"));
        CPPUNIT_ASSERT_EQUAL(previousTransmitCount, transmitMessages.size());
    }

    void testInitialReceiveAnswerWithBadSeq() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receiving an answer message with the Seq number 1 higher than expected
        auto lastTransmittedSeq = transmitMessages.back().mSeq;
        auto answerMessage = createAnswerMessage(lastTransmittedSeq+1, sdps, localSessionID, remoteSessionID);
        doTriggerReceiveValid(answerMessage);

        // since sequence number bad, we should not invoke answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveAnswerSdps.size());

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_ooo);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
    }

    void testReceiveAnswerWithBadSeq() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with a lower tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker - 1;
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, tieBreaker));

        // should NOT have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // trigger receiving an answer message
        auto lastTransmittedSeq = transmitMessages.back().mSeq;
        auto answerMessage = createAnswerMessage(lastTransmittedSeq+1, sdps, localSessionID, remoteSessionID);
        doTriggerReceiveValid(answerMessage);

        // Since bad seq number, we should not invoke answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveAnswerSdps.size());

        // should invoke the transmit callback with an error message
        validateErrorMessage(transmitMessages.back(), 3, localSessionID, remoteSessionID, roap_error_type_ooo);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
    }

    void testReceiveDuplicateAnswer() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receiving an answer message
        auto lastTransmittedSeq = transmitMessages.back().mSeq;
        auto answerMessage = createAnswerMessage(lastTransmittedSeq, sdps, localSessionID, remoteSessionID);
        doTriggerReceiveValid(answerMessage);

        // we should have invoked answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // try trigger receiving duplicate answer message with same sequence number
        doTriggerReceiveValid(answerMessage);

        // since duplicate answer with same sequence,
        // should not have invoked answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // try trigger receiving duplicate answer message with different sequence number
        answerMessage.mSeq++;
        doTriggerReceiveValid(answerMessage);

        // since duplicate answer with difference sequence,
        // should not have invoked answer received callback,
        // but should have sent error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_invalid_state);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
    }

    void testInitialTransmitOfferWithDuplicateAnswer() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        auto answerMessage = createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID);
        doTriggerReceiveValid(answerMessage);

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());

        // try trigger receiving duplicate answer message with same sequence number
        doTriggerReceiveValid(answerMessage);

        // since duplicate answer with same sequence,
        // should not have invoked answer receive callback,
        // but should have retransmitted ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        CPPUNIT_ASSERT(roap_message_type_ok == transmitMessages.back().mMessageType);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());

        // try trigger receiving duplicate answer message with different sequence number
        answerMessage.mSeq++;
        doTriggerReceiveValid(answerMessage);

        // since duplicate answer with difference sequence,
        // should have invoked answer received callback,
        // and should not have sent error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // should not invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
    }

    void testInitialTransmitOfferWithDuplicateAnswerAfterError() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        auto answerMessage = createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID);
        doTriggerReceiveValid(answerMessage);

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an error
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("incompatible codec(s)"));

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_failed);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());

        // try trigger receiving duplicate answer message with same sequence number
        doTriggerReceiveValid(answerMessage);

        // since duplicate answer with same sequence and we don't have an ok
        // previously, the answer should have been processed and answer receive callback should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveAnswerSdps.size());

        // trigger transmission of an error again
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("incompatible codec(s)"));

        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_failed);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void doReceiveSubsequentOfferRequestFlow() {
        // cleanup counters and what not
        initData();

        // trigger receive of an offer request
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, 0));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, true);

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testReceiveSubsequentOfferRequestFlow() {
        testInitialReceiveOfferRequestFlow();
        doReceiveSubsequentOfferRequestFlow();
    }

    void testReceiveSubsequentOfferRequestFlow2() {
        testInitialReceiveOfferFlow();
        doReceiveSubsequentOfferRequestFlow();
    }

    void testReceiveSubsequentOfferRequestFlow3() {
        testInitialTransmitOfferRequestFlow();
        doReceiveSubsequentOfferRequestFlow();
    }

    void testReceiveSubsequentOfferRequestFlow4() {
        testInitialTransmitOfferFlow();
        doReceiveSubsequentOfferRequestFlow();
    }

    void doReceiveSubsequentOfferFlow() {
        // cleanup counters and what not
        initData();

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, 0));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testReceiveSubsequentOfferFlow() {
        testInitialReceiveOfferFlow();
        doReceiveSubsequentOfferFlow();
    }

    void testReceiveSubsequentOfferFlow2() {
        testInitialReceiveOfferFlow();
        doReceiveSubsequentOfferFlow();
    }

    void testReceiveSubsequentOfferFlow3() {
        testInitialTransmitOfferRequestFlow();
        doReceiveSubsequentOfferFlow();
    }

    void testReceiveSubsequentOfferFlow4() {
        testInitialTransmitOfferFlow();
        doReceiveSubsequentOfferFlow();
    }

    void testReceiveDuplicateOfferRequest() {
        // trigger receive of an offer request
        auto offerRequestMessage = createOfferRequestMessage(1, localSessionID, remoteSessionID, 0);
        doTriggerReceiveValid(offerRequestMessage);

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());

        // try trigger receive of an exact duplicate offer request.
        // since seq number the same, this should be ignored.
        doTriggerReceiveValid(offerRequestMessage);

        // verify this duplicate offer request was not processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // verify seq number and increment it
        CPPUNIT_ASSERT_EQUAL(uint32_t(1), offerRequestMessage.mSeq);
        offerRequestMessage.mSeq++;

        // trigger receive of another offer request with higher seq number.
        doTriggerReceiveValid(offerRequestMessage);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
    }

    void doTransmitSubsequentOffer() {
        // cleanup counters and what not
        initData();

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testTransmitSubsequentOfferFlow() {
        testInitialReceiveOfferRequestFlow();
        doTransmitSubsequentOffer();
    }

    void testTransmitSubsequentOfferFlow2() {
        testInitialReceiveOfferFlow();
        doTransmitSubsequentOffer();
    }

    void testTransmitSubsequentOfferFlow3() {
        testInitialTransmitOfferRequestFlow();
        doTransmitSubsequentOffer();
    }

    void testTransmitSubsequentOfferFlow4() {
        testInitialTransmitOfferFlow();
        doTransmitSubsequentOffer();
    }

    void testTransmitSubsequentOfferFlowRetry() {
        testInitialTransmitOfferFlow();

        // cleanup counters and what not
        initData();

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // trigger receive of a retry error
        rs->receive(createErrorMessage(transmitMessages.back().mSeq, localSessionID, remoteSessionID, roap_error_type_retry, "errorCause"));

        // should invoke the transmit callback with retry of offer message with new seqnum
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 3, localSessionID, remoteSessionID, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

    void doTransmitSubsequentOfferRequest() {
        // cleanup counters and what not
        initData();

        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(transmitMessages.back().mSeq, sdps, remoteSessionID, localSessionID, 0));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
        CPPUNIT_ASSERT(!rs->isTransactionInProgress());
    }

    void testTransmitSubsequentOfferRequestFlow() {
        testInitialReceiveOfferRequestFlow();
        doTransmitSubsequentOfferRequest();
    }

    void testTransmitSubsequentOfferRequestFlow2() {
        testInitialReceiveOfferFlow();
        doTransmitSubsequentOfferRequest();
    }

    void testTransmitSubsequentOfferRequestFlow3() {
        testInitialTransmitOfferRequestFlow();
        doTransmitSubsequentOfferRequest();
    }

    void testTransmitSubsequentOfferRequestFlow4() {
        testInitialTransmitOfferFlow();
        doTransmitSubsequentOfferRequest();
    }

    void testTransmitSubsequentOfferRequestFlowRetry() {
        testInitialTransmitOfferFlow();

        // cleanup counters and what not
        initData();

        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of a retry error
        rs->receive(createErrorMessage(transmitMessages.back().mSeq, localSessionID, remoteSessionID, roap_error_type_retry, "errorCause"));

        // should invoke the transmit callback with retry of offer request message with new seqnum
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 3, remoteSessionID, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

    void testTransmitOfferWhenWaitingForRxOk() {
        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(transmitMessages.back().mSeq, sdps, remoteSessionID, localSessionID, 0));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmit of a new offer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // offer should be processed and transmit callback invoked with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

     void testTransmitOfferRequestWhenWaitingForRxOk() {
        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(transmitMessages.back().mSeq, sdps, remoteSessionID, localSessionID, 0));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmit of another offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // request should be processed and transmit callback invoked with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

    void doReceiveOutOfOrderSubsequentOfferRequest() {
        // cleanup counters and what not
        initData();

        // the original state
        auto origState = rs->getState();

        // trigger receive of an ooo offer request
        doTriggerReceiveValid(createOfferRequestMessage(1, localSessionID, remoteSessionID, 0));

        // should NOT have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(origState, rs->getState());

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_ooo);
    }

    void testReceiveOutOfOrderSubsequentOfferRequest() {
        testInitialReceiveOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest2() {
        testInitialReceiveOfferFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest3() {
        testInitialTransmitOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest4() {
        testInitialTransmitOfferFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest5() {
        testReceiveSubsequentOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest6() {
        testReceiveSubsequentOfferFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest7() {
        testTransmitSubsequentOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void testReceiveOutOfOrderSubsequentOfferRequest8() {
        testTransmitSubsequentOfferFlow();
        doReceiveOutOfOrderSubsequentOfferRequest();
    }

    void doReceiveOutOfOrderSubsequentOffer() {
        // cleanup counters and what not
        initData();

        // the original state
        auto origState = rs->getState();

        // trigger receive of an ooo offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(1, sdps, remoteSessionID, localSessionID, 0));

        // should NOT have invoked callback that an offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // state should NOT have changed
        CPPUNIT_ASSERT_EQUAL(origState, rs->getState());

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, roap_error_type_ooo);
    }

    void testReceiveOutOfOrderSubsequentOffer() {
        testInitialReceiveOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer2() {
        testInitialReceiveOfferFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer3() {
        testInitialTransmitOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer4() {
        testInitialTransmitOfferFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer5() {
        testReceiveSubsequentOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer6() {
        testReceiveSubsequentOfferFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer7() {
        testTransmitSubsequentOfferRequestFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveOutOfOrderSubsequentOffer8() {
        testTransmitSubsequentOfferFlow();
        doReceiveOutOfOrderSubsequentOffer();
    }

    void testReceiveDuplicateOffer() {
        // trigger receive of an offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(1, sdps, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offerMessage);

        // should have invoked callback that an offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // try trigger receive of an exact duplicate offer.
        // since seq number the same, this should be ignored.
        doTriggerReceiveValid(offerMessage);
        // verify this duplicate offer was not processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());

        // verify seq number and increment it
        CPPUNIT_ASSERT_EQUAL(uint32_t(1), offerMessage.mSeq);
        offerMessage.mSeq++;

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger receive of another offer with higher seq number.
        doTriggerReceiveValid(offerMessage);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
    }

     void testReceiveOfferWhenWaitingForOk() {
        // trigger receive of an initial offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(1, sdps, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offerMessage);

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // simulate receiving an exact duplicate offer.
        // this may happen if remote side did not receive our answer.
        // since seq number the same, we should transmit duplicate answer
        rs->receive(offerMessage);

        // verify this duplicate offer was not fully processed as a new event,
        // since seq number was the same
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT_EQUAL(uint32_t(1), offerMessage.mSeq);

        // since seq number the same, we should have transmitted the duplicate answer
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // increment seq number to simulate new offer event
        CPPUNIT_ASSERT_EQUAL(uint32_t(1), offerMessage.mSeq);
        offerMessage.mSeq++;

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // trigger receive of another offer with higher seq number.
        doTriggerReceiveValid(offerMessage);

        // should have injected a 'fake' ok callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
    }

    void testReceiveOfferWhenWaitingForTxOk() {
        doInitialReceiveOfferRequestFlow(false);
        initData();

        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(2, sdps, remoteSessionID, localSessionID, 2);

        // trigger receive of another offer with higher seq number.
        doTriggerReceiveValid(offerMessage);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // now if something triggers an ok to be sent, it will just get ignored
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOk());
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // state should still be the same
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
    }

     void testReceiveOfferRequestWhenWaitingForOk() {
        // trigger receive of an initial offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(1, sdps, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offerMessage);

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // simulate receiving an offer request with the same sequence
        // number.
        auto offerRequestMessage = createOfferRequestMessage(1, localSessionID, remoteSessionID, 0);
        doTriggerReceiveValid(offerRequestMessage);

        // this should be rejected with an invalid state error
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_invalid_state);

        // verify this offer request was not fully processed as a new
        // event, since seq number was the same
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // increment seq number to simulate new offer event
        offerRequestMessage.mSeq++;

        // trigger receive of another offer with higher seq number.
        doTriggerReceiveValid(offerRequestMessage);

        // should have injected a 'fake' ok callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
    }

    void testReceiveOfferRequestWhenWaitingForTxOk() {
        doInitialReceiveOfferRequestFlow(false);
        initData();

        auto offerRequestMessage = createOfferRequestMessage(2, localSessionID, remoteSessionID, 1);

        // trigger receive of another offer with higher seq number.
        doTriggerReceiveValid(offerRequestMessage);

        // since seq number higher, verify this valid new event is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());

        // now if something triggers an ok to be sent, it will just get ignored
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOk());
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // state should still be the same
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
    }

    void testOfferRequestOfferRequestGlareLocalLose() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with a higher tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker + 1;
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, tieBreaker));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());

        // send in the ERROR:CONFLICT message from the remote side
        // (the tieBreaker winner sends this)
        rs->receive(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, true);

        // send in another ERROR:CONFLICT message from the remote
        // side, testing conflict being received before or after our
        // offer goes out.  (the tieBreaker winner sends this)
        rs->receive(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testOfferRequestOfferRequestGlareLocalWin() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with a lower tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker - 1;
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, tieBreaker));

        // should NOT have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());

        // should send out an ERROR:CONFLICT message (the tieBreaker
        // winner sends this)
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_conflict);

        // trigger reception of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, 0));

        // should invoke the offer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, sdps);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
    }

    void testOfferRequestOfferRequestGlareLocalTie() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with the same tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker;
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, tieBreaker));

        // should NOT have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // should send out an ERROR:DOUBLE_CONFLICT and OFFER_REQUEST message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateErrorMessage(transmitMessages[1], 2, localSessionID, remoteSessionID, roap_error_type_double_conflict);
        validateOfferRequestMessage(transmitMessages[2], 3, remoteSessionID, localSessionID);

        // tieBreaker should have anew value
        CPPUNIT_ASSERT(*transmitMessages[2].mTieBreaker != tieBreaker);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());

        // send in the ERROR:DOUBLE_CONFLICT message from the remote side
        rs->receive(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_double_conflict, "errorCause"));

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
    }

    void testOfferRequestOfferRequestGlareNoTieBreaker() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with NO tie-breaker
        auto offerRequestMessage = createOfferRequestMessage(2, localSessionID, remoteSessionID, 0);
        offerRequestMessage.mTieBreaker = boost::none;
        doTriggerReceiveValid(offerRequestMessage);

        // should NOT have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // should have sent an error message
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_failed);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
    }

    void testOfferRequestReceiveNewerOfferRequestGlare() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with NO tie-breaker and a
        // higher/newer sequence number
        auto offerRequestMessage = createOfferRequestMessage(4, localSessionID, remoteSessionID, 0);
        offerRequestMessage.mTieBreaker = boost::none;
        doTriggerReceiveValid(offerRequestMessage);

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // Since remote has higher seq number, we lose glare and should
        // transition from WAIT_RX_OFFER to WAIT_TX_OFFER
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());
    }

    void testOfferRequestReceiveOlderOfferRequestGlare() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // send in a remote offer request with NO tie-breaker and a
        // lower/older sequence number
        auto offerRequestMessage = createOfferRequestMessage(1, localSessionID, remoteSessionID, 0);
        offerRequestMessage.mTieBreaker = boost::none;
        doTriggerReceiveValid(offerRequestMessage);

        // since lower/older sequence number, we should NOT have
        // invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // should have sent an error message for older message
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_ooo);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OFFER, rs->getState());
    }

    void testOfferOfferGlareLocalLose() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with a higher tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker + 1;
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, tieBreaker));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // send in the ERROR:CONFLICT message from the remote side
        // (the tieBreaker winner sends this)
        doTriggerReceiveValid(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
    }

    void testOfferOfferGlareLocalLoseErrorAfterTxAnswer() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with a higher tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker + 1;
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, tieBreaker));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // send in the ERROR:CONFLICT message from the remote side
        // (the tieBreaker winner sends this)
        doTriggerReceiveValid(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(transmitMessages.back().mSeq, remoteSessionID, localSessionID));

        // should have invoked callback that ok was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOkCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
    }

    void testOfferOfferGlareLocalWin() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with a lower tie-breaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker - 1;
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, tieBreaker));

        // should NOT have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // should send out an ERROR:CONFLICT message (the tieBreaker
        // winner sends this)
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, roap_error_type_conflict);

        // trigger reception of an answer
        doTriggerReceiveValid(createAnswerMessage(2, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testOfferOfferGlareLocalTie() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with the same tiebreaker
        uint32_t tieBreaker = *transmitMessages.back().mTieBreaker;
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, tieBreaker));

        // should NOT have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // should send out an ERROR:DOUBLE_CONFLICT message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateErrorMessage(transmitMessages[1], 2, remoteSessionID, localSessionID, roap_error_type_double_conflict);

        // should send out a new offer with a new sequence number and tiebreaker
        validateOfferMessage(transmitMessages[2], 3, localSessionID, remoteSessionID, sdps, false);
        CPPUNIT_ASSERT(*transmitMessages[2].mTieBreaker != tieBreaker);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // send in the ERROR:DOUBLE_CONFLICT message from the remote side
        rs->receive(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_double_conflict, "errorCause"));

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
    }

    void testOfferOfferGlareNoTieBreaker() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer with NO tie-breaker
        auto offerMessage = createOfferMessage(2, sdps, remoteSessionID, localSessionID, 0);
        offerMessage.mTieBreaker = boost::none;
        doTriggerReceiveValid(offerMessage);

        // should NOT have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // should have sent an error message
        validateErrorMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, roap_error_type_failed);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
    }

    void testOfferReceiveNewerOfferGlare() {
        // set things up
        testOfferOfferGlareNoTieBreaker();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // send in a remote offer request with NO tie-breaker and a
        // higher/newer sequence number
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(4, sdps, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offerMessage);

        // should have invoked callback that an offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());

        // Since remote has higher seq number, we lose glare and should
        // transition from WAIT_RX_ANSWER to WAIT_TX_ANSWER
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
    }

    void testOfferRequestOfferGlareLocalLose() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer request
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, 0xFFFFFFFF));

        // should NOT have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // should have re-transmitted our last offer
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, true);

        // send in the ERROR:CONFLICT message from the remote side
        // (the tieBreaker winner sends this)
        doTriggerReceiveValid(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testOfferRequestOfferGlareLocalLoseVersionTwo() {
        // set things up
        testInitialTransmitOfferFlowVersionTwo();
        initData();

        // trigger transmission of a subsequent offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // send in a remote offer request
        doTriggerReceiveValid(createOfferRequestMessage(2, boost::none, boost::none, 0xFFFFFFFF));

        // should have invoked callback that an offer request was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferRequestCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OFFER, rs->getState());

        // trigger transmission of our offer again
        sdps.resize(1);
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER_RESPONSE, rs->getState());

        // should have transmitted our last offer
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferResponseMessage(transmitMessages.back(), 2, sdps);

        // send in the ERROR:CONFLICT message from the remote side
        // (the tieBreaker winner sends this)
        doTriggerReceiveValid(createErrorMessage(2, boost::none, boost::none, roap_error_type_conflict, "errorCause"));

        // state should still be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER_RESPONSE, rs->getState());

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // should invoke the answer received callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveAnswerSdps.size());
        CPPUNIT_ASSERT(sdps == receiveAnswerSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_OK, rs->getState());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // should invoke the transmit callback with an ok message
        CPPUNIT_ASSERT_EQUAL(std::size_t(3), transmitMessages.size());
        validateOkMessage(transmitMessages.back(), 2, boost::none, boost::none);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testTransmitOfferEmptySDPs() {
        // trigger transmission of an offer with empty sdps
        std::vector<std::string> sdps;
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOffer(sdps, boost::none));

        // should NOT invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());
    }

    void testTransmitDuplicateOffer() {
        // get the initial stuff out of the way
        testInitialTransmitOfferFlow();

        initData();

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // try transmitting another offer. this is an error
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitOffer(sdps, boost::none));

        // this should NOT invoke transmit callback with another offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());

        // state should still be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

    void testTransmitAnswerEmptySDPs() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // trigger transmission of an answer with empty sdps
        sdps.clear();
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitAnswer(sdps, boost::none));

        // should NOT invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());
    }

    void testTransmitDuplicateAnswer() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // try to trigger transmission of another answer.
        // in WAIT_RX_OK state, this should get rejected without another transmit
        CPPUNIT_ASSERT_EQUAL(-1, rs->transmitAnswer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
    }

    void testNoRetransmitInitialOfferRequest() {
        // set the retransmission interval and timeout to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        testInitialTransmitOfferFlowVersionTwo();

        // should not retransmit
        auto xmitCount = transmitMessages.size();

        // retransmit timer should run and transaction timeout timer should pop
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(xmitCount, transmitMessages.size());

        // should not reschedule
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), context.GetIOService().run_one());

        // should not timeout
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), timeoutCount);
    }

    void testNoRetransmitInitialOffer() {
        // set the retransmission interval and timeout to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        testInitialTransmitOfferFlow();

        // should not retransmit
        auto xmitCount = transmitMessages.size();

        // retransmit timer should run and transaction timeout timer should pop
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(xmitCount, transmitMessages.size());

        // should not reschedule
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), context.GetIOService().run_one());

        // should not timeout
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), timeoutCount);
    }

    void testRetransmitInitialOfferRequest() {
        // set the retransmission interval to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));

        // send an offer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // should retransmit
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);
    }

    void testRetransmitInitialOffer() {
        // set the retransmission interval to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));

        // send an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // should retransmit
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);
    }

    void testRetransmitSubsequentOfferRequest() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // set the retransmission interval to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));

        // send an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID);

        // process the initial timer cancellation plus the timeout timer cancellation,
        // then should retransmit
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID);
    }

    void testRetransmitSubsequentOffer() {
        // set things up
        testInitialTransmitOfferFlow();
        initData();

        // set the retransmission interval to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));

        // send an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // process the initial timer cancellation plus the timeout timer cancellation,
        // then should retransmit
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);
    }

    void testRetransmitAnswer() {
        // set the retransmission interval to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));

        // receive an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // should retransmit
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);
    }

    void testInitialReceiveOfferRequestFlowReceiveError() {
        // trigger receive of an initial offer request
        doTriggerReceiveValid(createInitialOfferRequestMessage(remoteSessionID));

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // trigger receive of an error
        doTriggerReceiveValid(createErrorMessage(transmitMessages.back().mSeq, localSessionID, remoteSessionID, roap_error_type_failed, "errorCause"));

        // should invoke the error callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveErrorCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testInitialReceiveOfferFlowReceiveError() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // trigger receive of an error
        doTriggerReceiveValid(createErrorMessage(transmitMessages.back().mSeq, localSessionID, remoteSessionID, roap_error_type_failed, "errorCause"));

        // should invoke the error callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveErrorCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testInitialReceiveOfferRequestFlowTransmitErrorOnOfferRequest() {
        // trigger receive of an initial offer request
        doTriggerReceiveValid(createInitialOfferRequestMessage(remoteSessionID));

        // trigger transmission of an error
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("errorCause"));

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, roap_error_type_failed);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testInitialReceiveOfferRequestFlowTransmitErrorOnAnswer() {
        // trigger receive of an initial offer request
        doTriggerReceiveValid(createInitialOfferRequestMessage(remoteSessionID));

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // trigger receive of an answer
        doTriggerReceiveValid(createAnswerMessage(transmitMessages.back().mSeq, sdps, localSessionID, remoteSessionID));

        // trigger transmission of an error
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("errorCause"));

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, localSessionID, remoteSessionID, roap_error_type_failed);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_LOCAL_OFFER, rs->getState());
    }

    void testInitialReceiveOfferFlowTransmitError() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // trigger transmission of an error
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("errorCause"));

        // should invoke the transmit callback with an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, roap_error_type_failed);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_IDLE_REMOTE_OFFER, rs->getState());
    }

    void testReceiveAnswerWhenInErrorState() {
        // set things up, and begin in ERROR state
        testInitialReceiveOfferFlowReceiveError();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());

        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createAnswerMessage(2, sdps, localSessionID, remoteSessionID));

        // in ERROR state, should not have invoked callback for answer
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveAnswerSdps.size());

        // validate we send out an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_invalid_state);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testReceiveErrorWhenInErrorState() {
        // set things up, and begin in ERROR state
        testInitialReceiveOfferFlowReceiveError();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());

        // trigger receive of an error
        doTriggerReceiveValid(createErrorMessage(2, localSessionID, remoteSessionID, roap_error_type_failed, "errorCause"));

        // should not invoke the error callback when already in ERROR state
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveErrorCount);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testReceiveOfferRequestWhenInErrorState() {
        // set things up, and begin in ERROR state
        testInitialReceiveOfferFlowReceiveError();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());

        // trigger receive of an offer request
        doTriggerReceiveValid(createOfferRequestMessage(2, localSessionID, remoteSessionID, 0));

        // in ERROR state, should not have invoked callback for offer request
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // validate we send out an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_invalid_state);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testReceiveOfferWhenInErrorState() {
        // set things up, and begin in ERROR state
        testInitialReceiveOfferFlowReceiveError();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createOfferMessage(2, sdps, remoteSessionID, localSessionID, 0));

        // in ERROR state, should not have invoked callback for offer
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // validate we send out an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, roap_error_type_invalid_state);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testReceiveOkWhenInErrorState() {
        // set things up, and begin in ERROR state
        testInitialReceiveOfferFlowReceiveError();
        initData();

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());

        // trigger receive of an ok
        doTriggerReceiveValid(createOkMessage(2, remoteSessionID, localSessionID));

        // in ERROR state, should not have invoked callback for ok
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOkCount);

        // validate we send out an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, roap_error_type_invalid_state);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_ERROR, rs->getState());
    }

    void testBadFollowUpOfferWithMissingAnswerSessionId() {
        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // should have invoked callback that offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());
        CPPUNIT_ASSERT(sdps == receiveOfferSdps.back());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // should invoke the transmit callback with an answer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 1, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // trigger receive of a new offer with a missing answer session id
        auto seq_num = transmitMessages.back().mSeq;
        RoapMessage badOfferMsg(roap_version_one,
                                roap_message_type_offer,
                                seq_num,
                                sdps,
                                boost::none,
                                remoteSessionID,
                                boost::none,  // no answer session id
                                boost::none,
                                boost::none,
                                boost::none,
                                boost::none,
                                boost::none,
                                boost::none,
                                boost::none);

        // receive the bad message
        doTriggerReceiveValid(badOfferMsg);

        // validate we send out an error message
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateErrorMessage(transmitMessages.back(), seq_num, remoteSessionID, boost::none, roap_error_type_nomatch);
    }

    void testGetLastReceiveMessage() {
        // initially there is no message
        CPPUNIT_ASSERT( ! rs->getLastReceiveMessage() );

        // send in something invalid
        auto message = createInitialOfferRequestMessage(remoteSessionID);
        message.mVersion = "foobar";
        rs->receive(message);

        // still no message
        CPPUNIT_ASSERT( ! rs->getLastReceiveMessage() );

        message = createInitialOfferRequestMessage(remoteSessionID);
        rs->receive(message);

        // now we have a good message
        CPPUNIT_ASSERT( rs->getLastReceiveMessage() );
        CPPUNIT_ASSERT_EQUAL( message.mMessageType, rs->getLastReceiveMessage()->mMessageType );
    }

    void testGetVersion() {
        // defaults to version 1
        CPPUNIT_ASSERT_EQUAL( roap_version_one, rs->getVersion() );
    }

    void testSetVersion() {
        // cannot change to invalid version
        CPPUNIT_ASSERT_EQUAL( -1, rs->setVersion("foobar") );
        CPPUNIT_ASSERT_EQUAL( roap_version_one, rs->getVersion() );

        // can change to version 2
        CPPUNIT_ASSERT_EQUAL( 0, rs->setVersion(roap_version_two) );
        CPPUNIT_ASSERT_EQUAL( roap_version_two, rs->getVersion() );

        // can change to version 1
        CPPUNIT_ASSERT_EQUAL( 0, rs->setVersion(roap_version_one) );
        CPPUNIT_ASSERT_EQUAL( roap_version_one, rs->getVersion() );

        // cannot change after the session has started
        rs->transmitOfferRequest(boost::none);
        CPPUNIT_ASSERT_EQUAL( -1, rs->setVersion(roap_version_two) );
    }

    void testRemoteVersionChangeAfterInitialFlow() {
        // an arbitrary initial flow
        testInitialReceiveOfferRequestFlow();
        initData();

        // now send in a message with a changed version
        auto message = createOfferRequestMessage(2, localSessionID, remoteSessionID, 0);
        version = roap_version_two;
        doTriggerReceiveValid(message);

        // should NOT invoke callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferRequestCount);

        // should send out an error message
        version = roap_version_one;
        validateErrorMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, roap_error_type_refused);
    }

    void testInitialOfferRequestTimeout() {
        // set timeout to be very low
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        // send an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 1, boost::none, localSessionID);

        // should timeout
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        // should invoke timeout callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), timeoutCount);
    }

    void testInitialOfferTimeout() {
        // set timeout to be very low
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        // send an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 1, localSessionID, boost::none, sdps, false);

        // should timeout
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        // should invoke timeout callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), timeoutCount);
    }

    void testSubsequentOfferRequestTimeout() {
        // set retransmit and timeout to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        // first offer/answer succeeded
        testInitialReceiveOfferFlowVersionTwo();

        // clear transmit message
        transmitMessages.clear();

        // send an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferRequestMessage(transmitMessages.back(), 2, boost::none, boost::none);

        // clear transmit message
        transmitMessages.clear();

        // let it run some
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        // there should be some retransmit
        CPPUNIT_ASSERT(transmitMessages.size() > 0);

        // and timeout callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), timeoutCount);
    }

    void testSubsequentOfferTimeout() {
        // set retransmit and timeout to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        // first offer/answer succeeded
        testInitialReceiveOfferFlow();

        // clear transmit message
        transmitMessages.clear();

        // send an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateOfferMessage(transmitMessages.back(), 2, localSessionID, remoteSessionID, sdps, false);

        // clear transmit message
        transmitMessages.clear();

        // let it run some
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        // there should be some retransmit
        CPPUNIT_ASSERT(transmitMessages.size() > 0);

        // and timeout callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), timeoutCount);
    }

    void testOfferAnswerNoOkTimeout() {
        // set retransmit and timeout to be very low
        rs->setRetransmitDuration(std::chrono::seconds(0));
        rs->setTransactionTimeoutDuration(std::chrono::seconds(0));

        // trigger receive of an initial offer request
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        doTriggerReceiveValid(createInitialOfferMessage(sdps, remoteSessionID));

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // let it run
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), context.GetIOService().run_one());

        // there should be a timeout callback
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), timeoutCount);
    }

    void testReceiveOutOfOrderOutOfOrderError() {
        // get initial stuff out of the way
        testInitialReceiveOfferFlow();

        initData();

        // trigger receive of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        auto offerMessage = createOfferMessage(2, sdps, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offerMessage);

        // should have invoked callback that an offer was received
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // an answer should be transmitted
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 2, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // now trigger receive of another offer with higher seq number
        offerMessage.mSeq++;
        doTriggerReceiveValid(offerMessage);

        // verify this is processed
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), receiveOfferSdps.size());

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_TX_ANSWER, rs->getState());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer(sdps, boost::none));

        // an answer should be transmitted
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
        validateAnswerMessage(transmitMessages.back(), 3, remoteSessionID, localSessionID, sdps);

        // state should be correct
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_WAIT_RX_OK, rs->getState());

        // our previous answer got an ooo error with old sequence number
        doTriggerReceiveValid(createErrorMessage(2, remoteSessionID, localSessionID, roap_error_type_ooo,
                                                 "received seq 2 expected at least 3"));

        // this should *not* trigger another ooo error on our side
        CPPUNIT_ASSERT_EQUAL(std::size_t(2), transmitMessages.size());
    }

    void testReceiveInvalidMessageStats() {
        testInitialTransmitOfferFlow();

        // receive an offer with old seq number
        auto offer = createOfferMessage(0, {"sdp"}, remoteSessionID, localSessionID, 0);
        doTriggerReceiveValid(offer);

        // receive an invalid message (offer with no sdp)
        offer.mSeq = 2;
        offer.mSdps = boost::none;

        doTriggerReceiveValid(offer);

        auto receiveStats = rs->getReceiveStats();
        auto transmitStats = rs->getTransmitStats();

        // from the first transmit offer flow
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), transmitStats[roap_message_type_offer]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), receiveStats[roap_message_type_answer]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), transmitStats[roap_message_type_ok]);

        CPPUNIT_ASSERT_EQUAL(uint64_t(1), receiveStats[roap_message_type_offer]);
        CPPUNIT_ASSERT_EQUAL(uint64_t(1), transmitStats[roap_message_type_error]);

        CPPUNIT_ASSERT_EQUAL(uint64_t(1), receiveStats["INVALID"]);
    }

    void testStartingSeqNumber() {
        createRoapSession(6);

        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());

        // seq number should be right (last seq was 6, so this transaction should be 7)
        validateOfferMessage(transmitMessages.back(), 7, localSessionID, boost::none, sdps, false);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_ANSWER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());

        // another try, this time starting with an offer request
        createRoapSession(100);
        initData();

        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // should invoke the transmit callback with an offer request message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());
        // sequence number should be right
        validateOfferRequestMessage(transmitMessages.back(), 101, boost::none, localSessionID);

        // state should be right
        CPPUNIT_ASSERT_EQUAL(ROAP_STATE_INIT_WAIT_RX_OFFER, rs->getState());
        CPPUNIT_ASSERT(rs->isTransactionInProgress());
    }

    void testSuspension() {
        CPPUNIT_ASSERT_EQUAL(rs->isSuspended(), false);

        RoapState startingState = rs->getState();

        // suspend this session
        rs->setSuspensionState(true);

        CPPUNIT_ASSERT_EQUAL(rs->isSuspended(), true);

        // trigger receive of an offer
        doTriggerReceiveValid(createInitialOfferMessage({"sdp"}, remoteSessionID));

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), receiveOfferSdps.size());

        // state should still be the same
        CPPUNIT_ASSERT_EQUAL(startingState, rs->getState());
        // no transaction should be in progress
        CPPUNIT_ASSERT(! rs->isTransactionInProgress());

        // trigger transmission of an offer request
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOfferRequest(boost::none));

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // trigger transmission of an offer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer({"sdp"}, boost::none));

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // trigger transmission of an answer
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitAnswer({"sdp"}, boost::none));

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // trigger transmission of an ok
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOk());

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // trigger transmission of an error
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitError("unknown"));

        // nothing should have been invoked
        CPPUNIT_ASSERT_EQUAL(std::size_t(0), transmitMessages.size());

        // state should still be the same
        CPPUNIT_ASSERT_EQUAL(startingState, rs->getState());
        // no transaction should be in progress
        CPPUNIT_ASSERT(! rs->isTransactionInProgress());

        // resume this session
        rs->setSuspensionState(false);

        // should no longer be suspended
        CPPUNIT_ASSERT_EQUAL(rs->isSuspended(), false);

        // verifying this by starting a transmit offer request flow
        testInitialTransmitOfferRequestFlow();
    }

    void testGetCurrentSeqNumber() {
        // trigger transmission of an offer
        std::vector<std::string> sdps{"sdp1", "sdp2"};
        CPPUNIT_ASSERT_EQUAL(0, rs->transmitOffer(sdps, boost::none));

        // should invoke the transmit callback with an offer message
        CPPUNIT_ASSERT_EQUAL(std::size_t(1), transmitMessages.size());

        // seq number should be right
        validateOfferMessage(transmitMessages.back(), rs->getCurrentSeq(), localSessionID, boost::none, sdps, false);
    }

    CPPUNIT_TEST_SUITE(TestRoapSession);
    CPPUNIT_TEST(testDefaultState);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlow);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlowVersionTwo);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlowVersionThree);
    CPPUNIT_TEST(testInitialReceiveOfferFlow);
    CPPUNIT_TEST(testInitialReceiveOfferFlowVersionTwo);
    CPPUNIT_TEST(testInitialReceiveOfferFlowDuplicateOk);
    CPPUNIT_TEST(testInitialReceiveBadOffer);
    CPPUNIT_TEST(testInitialTransmitOfferRequestFlow);
    CPPUNIT_TEST(testInitialTransmitOfferRequestFlowVersionTwo);
    CPPUNIT_TEST(testInitialTransmitDuplicateOfferRequest);
    CPPUNIT_TEST(testInitialTransmitOfferFlow);
    CPPUNIT_TEST(testInitialTransmitOfferFlowVersionTwo);
    CPPUNIT_TEST(testInitialTransmitOfferFlowStats);
    CPPUNIT_TEST(testInitialTransmitDuplicateOffer);
    CPPUNIT_TEST(testInitialTransmitOfferWithDuplicateAnswer);
    CPPUNIT_TEST(testInitialTransmitOfferWithDuplicateAnswerAfterError);
    CPPUNIT_TEST(testInitialTransmitOfferWithDuplicateOk);
    CPPUNIT_TEST(testInitialTransmitOfferWithErrorMessage);
    CPPUNIT_TEST(testInitialReceiveAnswerWithBadSeq);
    CPPUNIT_TEST(testReceiveAnswerWithBadSeq);
    CPPUNIT_TEST(testReceiveDuplicateAnswer);
    CPPUNIT_TEST(testReceiveSubsequentOfferRequestFlow);
    CPPUNIT_TEST(testReceiveSubsequentOfferRequestFlow2);
    CPPUNIT_TEST(testReceiveSubsequentOfferRequestFlow3);
    CPPUNIT_TEST(testReceiveSubsequentOfferRequestFlow4);
    CPPUNIT_TEST(testReceiveDuplicateOfferRequest);
    CPPUNIT_TEST(testReceiveSubsequentOfferFlow);
    CPPUNIT_TEST(testReceiveSubsequentOfferFlow2);
    CPPUNIT_TEST(testReceiveSubsequentOfferFlow3);
    CPPUNIT_TEST(testReceiveSubsequentOfferFlow4);
    CPPUNIT_TEST(testTransmitSubsequentOfferRequestFlow);
    CPPUNIT_TEST(testTransmitSubsequentOfferRequestFlow2);
    CPPUNIT_TEST(testTransmitSubsequentOfferRequestFlow3);
    CPPUNIT_TEST(testTransmitSubsequentOfferRequestFlow4);
    CPPUNIT_TEST(testTransmitSubsequentOfferRequestFlowRetry);
    CPPUNIT_TEST(testTransmitOfferWhenWaitingForRxOk);
    CPPUNIT_TEST(testTransmitOfferRequestWhenWaitingForRxOk);
    CPPUNIT_TEST(testTransmitSubsequentOfferFlow);
    CPPUNIT_TEST(testTransmitSubsequentOfferFlow2);
    CPPUNIT_TEST(testTransmitSubsequentOfferFlow3);
    CPPUNIT_TEST(testTransmitSubsequentOfferFlow4);
    CPPUNIT_TEST(testTransmitSubsequentOfferFlowRetry);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest2);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest3);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest4);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest5);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest6);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest7);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOfferRequest8);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer2);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer3);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer4);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer5);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer6);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer7);
    CPPUNIT_TEST(testReceiveOutOfOrderSubsequentOffer8);
    CPPUNIT_TEST(testReceiveDuplicateOffer);
    CPPUNIT_TEST(testReceiveOfferWhenWaitingForOk);
    CPPUNIT_TEST(testReceiveOfferWhenWaitingForTxOk);
    CPPUNIT_TEST(testReceiveOfferRequestWhenWaitingForOk);
    CPPUNIT_TEST(testReceiveOfferRequestWhenWaitingForTxOk);
    CPPUNIT_TEST(testOfferRequestOfferRequestGlareLocalLose);
    CPPUNIT_TEST(testOfferRequestOfferRequestGlareLocalWin);
    CPPUNIT_TEST(testOfferRequestOfferRequestGlareLocalTie);
    CPPUNIT_TEST(testOfferRequestOfferRequestGlareNoTieBreaker);
    CPPUNIT_TEST(testOfferRequestReceiveNewerOfferRequestGlare);
    CPPUNIT_TEST(testOfferRequestReceiveOlderOfferRequestGlare);
    CPPUNIT_TEST(testOfferOfferGlareLocalLose);
    CPPUNIT_TEST(testOfferOfferGlareLocalLoseErrorAfterTxAnswer);
    CPPUNIT_TEST(testOfferOfferGlareLocalWin);
    CPPUNIT_TEST(testOfferOfferGlareLocalTie);
    CPPUNIT_TEST(testOfferOfferGlareNoTieBreaker);
    CPPUNIT_TEST(testOfferReceiveNewerOfferGlare);
    CPPUNIT_TEST(testOfferRequestOfferGlareLocalLose);
    CPPUNIT_TEST(testOfferRequestOfferGlareLocalLoseVersionTwo);
    CPPUNIT_TEST(testTransmitOfferEmptySDPs);
    CPPUNIT_TEST(testTransmitDuplicateOffer);
    CPPUNIT_TEST(testTransmitAnswerEmptySDPs);
    CPPUNIT_TEST(testTransmitDuplicateAnswer);
    CPPUNIT_TEST(testNoRetransmitInitialOfferRequest);
    CPPUNIT_TEST(testNoRetransmitInitialOffer);
    CPPUNIT_TEST(testRetransmitInitialOfferRequest);
    CPPUNIT_TEST(testRetransmitInitialOffer);
    CPPUNIT_TEST(testRetransmitSubsequentOfferRequest);
    CPPUNIT_TEST(testRetransmitSubsequentOffer);
    CPPUNIT_TEST(testRetransmitAnswer);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlowReceiveError);
    CPPUNIT_TEST(testInitialReceiveOfferFlowReceiveError);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlowTransmitErrorOnOfferRequest);
    CPPUNIT_TEST(testInitialReceiveOfferRequestFlowTransmitErrorOnAnswer);
    CPPUNIT_TEST(testInitialReceiveOfferFlowTransmitError);
    CPPUNIT_TEST(testReceiveAnswerWhenInErrorState);
    CPPUNIT_TEST(testReceiveErrorWhenInErrorState);
    CPPUNIT_TEST(testReceiveOfferRequestWhenInErrorState);
    CPPUNIT_TEST(testReceiveOfferWhenInErrorState);
    CPPUNIT_TEST(testReceiveOkWhenInErrorState);
    CPPUNIT_TEST(testBadFollowUpOfferWithMissingAnswerSessionId);
    CPPUNIT_TEST(testGetLastReceiveMessage);
    CPPUNIT_TEST(testGetVersion);
    CPPUNIT_TEST(testSetVersion);
    CPPUNIT_TEST(testRemoteVersionChangeAfterInitialFlow);
    CPPUNIT_TEST(testInitialOfferRequestTimeout);
    CPPUNIT_TEST(testInitialOfferTimeout);
    CPPUNIT_TEST(testSubsequentOfferRequestTimeout);
    CPPUNIT_TEST(testSubsequentOfferTimeout);
    CPPUNIT_TEST(testOfferAnswerNoOkTimeout);
    CPPUNIT_TEST(testReceiveOutOfOrderOutOfOrderError);
    CPPUNIT_TEST(testReceiveInvalidMessageStats);
    CPPUNIT_TEST(testStartingSeqNumber);
    CPPUNIT_TEST(testSuspension);
    CPPUNIT_TEST(testGetCurrentSeqNumber);
    CPPUNIT_TEST_SUITE_END();
};


CPPUNIT_TEST_SUITE_REGISTRATION(TestRoapSession);
