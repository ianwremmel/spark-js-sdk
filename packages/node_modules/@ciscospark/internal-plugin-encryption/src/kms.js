/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import querystring from 'querystring';
import util from 'util';

import {omit} from 'lodash';
import jose from 'node-jose';
import {Context, Request, Response} from 'node-kms';
import {safeSetTimeout} from '@ciscospark/common-timers';
import {oneFlight} from '@ciscospark/common';
import {SparkPlugin} from '@ciscospark/spark-core';

import KMSBatcher, {TIMEOUT_SYMBOL} from './kms-batcher';

const contexts = new WeakMap();
const kmsDetails = new WeakMap();
const partialContexts = new WeakMap();

/**
 * @class
 */
const KMS = SparkPlugin.extend({
  namespace: 'Encryption',

  children: {
    /**
     * @instance
     * @memberof KMS
     * @private
     * @type {KMSBatcher}
     */
    batcher: KMSBatcher
  },

  /**
   * Binds a key to a resource
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {KMSResourceObject} options.kro
   * @param {string} options.kroUri
   * @param {Key} options.key
   * @param {string} options.keyUri
   * @returns {Promise<Key>}
   */
  bindKey({
    kro, kroUri, key, keyUri
  } = {}) {
    kroUri = kroUri || kro.uri;
    keyUri = keyUri || key.uri;

    this.logger.info('kms: binding key to resource');

    /* istanbul ignore if */
    if (!kroUri) {
      return Promise.reject(new Error('`kro` or `kroUri` is required'));
    }

    /* istanbul ignore if */
    if (!keyUri) {
      return Promise.reject(new Error('`key` or `keyUri` is required'));
    }

    return this.request({
      method: 'update',
      resourceUri: kroUri,
      uri: keyUri
    })
      .then((res) => {
        this.logger.info('kms: bound key to resource');
        return res.key;
      });
  },

  /**
   * Creates a new KMS Resource
   *
   * Note: You *must* include yourself in the list of users authorized to this
   * KRO if you intend to make additional modifications to it. You'll want to do
   * so in most cases, but there are automation use cases where that doesn't
   * make sense; we've taken the approach that you must opt-in to all
   * authorization grants and avoid doing anything by default.
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {Array<string>} options.userIds
   * @param {Array<string>} options.keyUris
   * @param {Key} options.key
   * @param {Array<Keys>} options.keys
   * @returns {Promise<KMSResourceObject>}
   * @example
   * <caption>Create a KMS Resource Object on the Key Managemnt Server and bind a key to it</caption>
   * spark.internal.encryption.kms.createUnboundKeys()
   *   .then(([key]) => spark.internal.encryption.kms.createResource({
   *      userIds: [spark.internal.device.userId],
   *      key
   *    }))
   *    .then((kro) => {
   *      return 'success';
   *    });
   *    // => success
   */
  createResource({
    userIds, keyUris = [], key, keys
  } = {}) {
    /* istanbul ignore if */
    if (keys) {
      keyUris = keys.reduce((uris, k) => {
        uris.push(k.uri);
        return uris;
      }, keyUris);
    }

    /* istanbul ignore else */
    if (key) {
      keyUris.push(key.uri);
    }

    /* istanbul ignore if */
    if (keyUris.length === 0) {
      return Promise.reject(new Error('Cannot create KMS Resource without at least one keyUri'));
    }

    this.logger.info('kms: creating resource');

    return this.request({
      method: 'create',
      uri: '/resources',
      userIds,
      keyUris
    })
      .then((res) => {
        this.logger.info('kms: created resource');
        return res.resource;
      });
  },

  /**
   * Authorizes a user or KRO to a KRO
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {Array<string>} options.userIds
   * @param {Array<string>} options.authIds interchangable with userIds
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Promise<KMSAuthorizationObject>}
   * @example
   * <caption>Give a user access to a key</caption>
   * spark.internal.encryption.kms.addAuthorization({
   *   userIds: [alice.id],
   *   kroUri: kro.uri
   * })
   *   .then(([auth]) => {
   *     return 'success';
   *   });
   *   // => success
   * @example
   * <caption>Give a resource access to a key</caption>
   * spark.internal.encryption.kms.createUnboundKeys()
   *  .then(([key]) => spark.internal.encryption.kms.createResource({key}))
   *  .then((kro2) => {
   *    kro2
   *    return spark.internal.encryption.kms.addAuthorization({
   *      authIds: [kro2.uri],
   *      kro
   *    });
   *  })
   *  .then(() => {
   *    return 'success';
   *  })
   *  // => success
   */
  addAuthorization({
    userIds = [], authIds, kro, kroUri
  } = {}) {
    kroUri = kroUri || kro.uri;

    if (authIds) {
      userIds = userIds.concat(authIds);
    }

    /* istanbul ignore if */
    if (userIds.length === 0) {
      return Promise.reject(new Error('Cannot add authorization without userIds or authIds'));
    }

    /* istanbul ignore if */
    if (!kroUri) {
      return Promise.reject(new Error('`kro` or `kroUri` is required'));
    }

    this.logger.info('kms: adding authorization to kms resource');

    return this.request({
      method: 'create',
      uri: '/authorizations',
      resourceUri: kroUri,
      userIds
    })
      .then((res) => {
        this.logger.info('kms: added authorization');
        return res.authorizations;
      });
  },

  /**
   * Retrieve a list of users that have been authorized to the KRO
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Array<authId>}
   */
  listAuthorizations({kro, kroUri} = {}) {
    kroUri = kroUri || kro.uri;
    /* istanbul ignore if */
    if (!kroUri) {
      return Promise.reject(new Error('`kro` or `kroUri` is required'));
    }
    return this.request({
      method: 'retrieve',
      uri: `${kroUri}/authorizations`
    })
      .then((res) => {
        this.logger.info('kms: retrieved authorization list');
        return res.authorizations;
      });
  },

  /**
   * Deauthorizes a user or KRO from a KRO
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {string} options.userId
   * @param {string} options.authId interchangable with userIds
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Promise<KMSAuthorizationObject>}
   */
  removeAuthorization({
    authId, userId, kro, kroUri
  } = {}) {
    authId = authId || userId;
    kroUri = kroUri || kro.uri;

    /* istanbul ignore if */
    if (!authId) {
      return Promise.reject(new Error('Cannot remove authorization without authId'));
    }

    /* istanbul ignore if */
    if (!kroUri) {
      return Promise.reject(new Error('`kro` or `kroUri` is required'));
    }

    this.logger.info('kms: removing authorization from kms resource');

    return this.request({
      method: 'delete',
      uri: `${kroUri}/authorizations?${querystring.stringify({authId})}`
    })
      .then((res) => {
        this.logger.info('kms: removed authorization');
        return res.authorizations;
      });
  },

  /**
   * Requests `count` unbound keys from the kms
   * @instance
   * @memberof KMS
   * @param {Object} [options]
   * @param {number} [options.count=1]
   * @returns {Promise<Array<Key>>}
   * @example
   * <caption>Create a new key</caption>
   * spark.internal.encryption.kms.createUnboundKeys()
   *   .then(([key]) => {
   *     return 'success';
   *   })
   *   // => success
   * @example
   * <caption>Create 2 new keys</caption>
   * spark.internal.encryption.kms.createUnboundKeys({count: 2})
   *   .then((keys) => {
   *     return 'success';
   *   })
   *   // => success
   */
  createUnboundKeys(options = {}) {
    const count = options.count || 1;
    this.logger.info(`kms: request ${count} unbound keys`);

    /* istanbul ignore if */
    if (!count) {
      return Promise.reject(new Error('`options.count` is required'));
    }

    return this.request({
      method: 'create',
      uri: '/keys',
      count
    })
      .then((res) => {
        this.logger.info('kms: received unbound keys');
        return Promise.all(res.keys.map(this.asKey));
      });
  },

  // Ideally, this would be done via the kms batcher, but other than request id,
  // there isn't any other userful key in a kms response to match it to a
  // request. as such, we need the batcher to group requests, but one flight to
  // make sure we don't make the same request multiple times.
  @oneFlight({
    keyFactory: ({uri}) => uri
  })
  /**
   * Fetches the specified key from the kms
   * @instance
   * @memberof KMS
   * @param {Object} options
   * @param {string} options.uri
   * @returns {Promise<Key>}
   * @example
   * <caption>Fetch a key by url</caption>
   * let keyUri;
   * spark.internal.encryption.kms.createUnboundKeys({count: 1})
   *   .then(([key]) => {
   *     keyUri = key.uri
   *   })
   *   .then(() => spark.internal.encryption.kms.fetchKey({uri: keyUri}))
   *   .then((key) => {
   *     return 'success';
   *   })
   *   // => success
   */
  fetchKey({uri} = {}) {
    /* istanbul ignore if */
    if (!uri) {
      return Promise.reject(new Error('`options.uri` is required'));
    }

    this.logger.info('kms: fetching key');

    return this.request({
      method: 'retrieve',
      uri
    })
      .then((res) => {
        this.logger.info('kms: fetched key');
        return this.asKey(res.key);
      });
  },

  /**
   * Pings the kms. Mostly for testing
   * @instance
   * @memberof KMS
   * @returns {Promise}
   * @example
   * <caption>Ping the kms</caption>
   * spark.internal.encryption.kms.ping()
   *   .then(() => {
   *     return 'success';
   *   })
   *   // => success
   */
  ping() {
    return this.request({
      method: 'update',
      uri: '/ping'
    });
  },

  /**
   * Ensures a key object is a @{link Key} instance. This should never need to
   * be invoked directly.
   * @instance
   * @memberof KMS
   * @param {Object|Key} key
   * @returns {Promise<Key>}
   * @example
   * <caption>Convert a key object to a Key instance</caption>
   * let keyObj;
   * spark.internal.encryption.kms.createUnboundKeys({count: 1})
   *   .then(([key]) => {
   *     keyObj = JSON.parse(JSON.stringify(key));
   *     keyObj.jwk = key.jwk.toJSON(true);
   *   })
   *   .then(() => spark.internal.encryption.kms.asKey(keyObj))
   *   .then((key) => {
   *     return 'success';
   *   })
   *   // => success
   */
  asKey(key) {
    return jose.JWK.asKey(key.jwk)
      .then((jwk) => {
        key.jwk = jwk;
        return key;
      });
  },

  /**
   * Adds appropriate metadata to the KMS request. This method should be called
   * automatically via a payload transform, so there shouldn't be any need to
   * call it directly.
   * @instance
   * @memberof KMS
   * @param {Object} payload
   * @private
   * @returns {Promise<KMS.Request>}
   */
  prepareRequest(payload) {
    const isECDHRequest = payload.method === 'create' && payload.uri.includes('/ecdhe');
    return Promise.resolve(isECDHRequest ? partialContexts.get(this) : this._getContext())
      .then((context) => {
        this.logger.info(`kms: wrapping ${isECDHRequest ? 'ephemeral key' : 'kms'} request`);
        const req = new Request(payload);
        return req.wrap(context, {serverKey: isECDHRequest})
          .then(() => {
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              this.logger.info('kms: request payload', util.inspect(omit(JSON.parse(JSON.stringify(req)), 'wrapped'), {depth: null}));
            }
            return req;
          });
      });
  },

  /**
   * Accepts a kms message event, decrypts it, and passes it to the batcher
   * @instance
   * @memberof KMS
   * @param {Object} event
   * @private
   * @returns {Promise<Object>}
   */
  processKmsMessageEvent(event) {
    this.logger.info('kms: received kms message');
    return Promise.all(event.encryption.kmsMessages.map((kmsMessage, index) => this._isECDHEMessage(kmsMessage)
      .then((isECDHMessage) => {
        this.logger.info(`kms: received ${isECDHMessage ? 'ecdhe' : 'normal'} message`);
        const res = new Response(kmsMessage);
        return Promise.resolve(isECDHMessage ? partialContexts.get(this) : contexts.get(this))
          // eslint-disable-next-line max-nested-callbacks
          .then((context) => res.unwrap(context))
          // eslint-disable-next-line max-nested-callbacks
          .then(() => {
            if (process.env.NODE_ENV !== 'production') {
              this.logger.info('kms: response payload', util.inspect(omit(JSON.parse(JSON.stringify(res)), 'wrapped'), {depth: null}));
            }
          })
          // eslint-disable-next-line max-nested-callbacks
          .then(() => { event.encryption.kmsMessages[index] = res; })
          // eslint-disable-next-line max-nested-callbacks
          .then(() => res);
      })))
      .then(() => this.batcher.processKmsMessageEvent(event))
      .catch((reason) => {
        this.logger.error('kms: decrypt failed', reason.stack);
        return Promise.reject(reason);
      })
      .then(() => event);
  },

  /**
   * Decrypts a kms message. Useful for decrypt a DRY sidecard payload. Should
   * be invoked automatically by a payload transform.
   * @instance
   * @memberof KMS
   * @param {Object} kmsMessage
   * @private
   * @returns {Promise<Object>}
   */
  decryptKmsMessage(kmsMessage) {
    const res = new Response(kmsMessage);
    return contexts.get(this)
      .then((context) => res.unwrap(context))
      .then(() => res.body);
  },

  /**
   * Determines if the kms message is an ecdhe message or a normal message
   * @instance
   * @memberof KMS
   * @param {Object} kmsMessage
   * @private
   * @returns {Promise<boolean>}
   */
  _isECDHEMessage(kmsMessage) {
    return this._getKMSStaticPubKey()
      .then((kmsStaticPubKey) => {
        const fields = kmsMessage.split('.');

        if (fields.length !== 3) {
          return false;
        }

        const header = JSON.parse(jose.util.base64url.decode(fields[0]));

        return header.kid === kmsStaticPubKey.kid;
      });
  },

  /**
   * Sends a request to the kms
   * @instance
   * @memberof KMS
   * @param {Object} payload
   * @param {number} timeout (internal)
   * @private
   * @returns {Promise<Object>}
   */
  request(payload, timeout) {
    timeout = timeout || this.config.kmsInitialTimeout;

    // Note: this should only happen when we're using the async kms batcher;
    // once we implement the sync batcher, this'll need to be smarter.
    return this.spark.internal.mercury.connect()
      .then(() => this.prepareRequest(payload))
      .then((req) => {
        req[TIMEOUT_SYMBOL] = timeout;
        return this.batcher.request(req);
      })
      // High complexity is due to attempt at test mode resiliency
      // eslint-disable-next-line complexity
      .catch((reason) => {
        if (process.env.NODE_ENV === 'test' && (reason.status === 403 || reason.statusCode === 403) && reason.message.match(/Failed to resolve authorization token in KmsMessage request for user/)) {
          this.logger.warn('kms: rerequested key due to test-mode kms auth failure');
          return this.request(payload);
        }

        // Ideally, most or all of the code below would go in kms-batcher, but
        // but batching needs at least one more round of refactoring for that to
        // work.
        if (!reason.statusCode && !reason.status) {
          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            /* istanbul ignore next: reason.stack vs stack difficult to control in test */
            this.logger.info('kms: request error', reason.stack || reason);
          }

          timeout *= 2;

          if (timeout >= this.config.kmsMaxTimeout) {
            this.logger.info('kms: exceeded maximum KMS request retries; negotiating new ecdh key');

            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              this.logger.info('kms: timeout/maxtimeout', timeout, this.config.kmsMaxTimeout);
            }

            contexts.delete(this);
            timeout = 0;
          }

          return this.request(payload, timeout);
        }

        return Promise.reject(reason);
      });
  },

  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<string>}
   */
  _getAuthorization() {
    return this.spark.credentials.getUserToken('spark:kms')
      .then((token) => token.access_token);
  },

  @oneFlight
  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<Object>}
   */
  _getContext() {
    let promise = contexts.get(this);
    if (!promise) {
      promise = this._prepareContext();
      contexts.set(this, promise);
      promise.then((context) => {
        const expiresIn = context.ephemeralKey.expirationDate - Date.now() - 30000;
        safeSetTimeout(() => contexts.delete(this), expiresIn);
      });
    }

    return Promise.all([
      promise,
      this._getAuthorization()
    ])
      .then(([context, authorization]) => {
        context.clientInfo.credential.bearer = authorization;
        return context;
      });
  },

  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSCluster() {
    this.logger.info('kms: retrieving KMS cluster');
    return this._getKMSDetails()
      .then(({kmsCluster}) => kmsCluster);
  },

  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSDetails() {
    let details = kmsDetails.get(this);
    if (!details) {
      this.logger.info('kms: fetching KMS details');
      details = this.spark.request({
        service: 'encryption',
        resource: `/kms/${this.spark.internal.device.userId}`
      })
        .then((res) => {
          this.logger.info('kms: fetched KMS details');
          const {body} = res;
          body.rsaPublicKey = JSON.parse(body.rsaPublicKey);
          return body;
        })
        .catch((reason) => {
          this.logger.error('kms: failed to fetch KMS details', reason);
          return Promise.reject(reason);
        });

      kmsDetails.set(this, details);
    }

    return details;
  },

  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSStaticPubKey() {
    this.logger.info('kms: retrieving KMS static public key');
    return this._getKMSDetails()
      .then(({rsaPublicKey}) => rsaPublicKey);
  },

  /**
   * @instance
   * @memberof KMS
   * @private
   * @returns {Promise<Object>}
   */
  _prepareContext() {
    this.logger.info('kms: creating context');
    const context = new Context();

    return Promise.all([
      this._getKMSStaticPubKey(),
      this._getAuthorization()
    ])
      .then(([kmsStaticPubKey, authorization]) => {
        context.clientInfo = {
          clientId: this.spark.internal.device.url,
          credential: {
            userId: this.spark.internal.device.userId,
            bearer: authorization
          }
        };

        context.serverInfo = {
          key: kmsStaticPubKey
        };

        this.logger.info('kms: creating local ephemeral key');
        return context.createECDHKey();
      })
      .then((localECDHKey) => {
        context.ephemeralKey = localECDHKey;
        partialContexts.set(this, context);
        return Promise.all([localECDHKey.asKey(), this._getKMSCluster()]);
      })
      .then(([localECDHKey, cluster]) => {
        this.logger.info('kms: submitting ephemeral key request');
        return this.request({
          uri: `${cluster}/ecdhe`,
          method: 'create',
          jwk: localECDHKey.toJSON()
        });
      })
      .then((res) => {
        this.logger.info('kms: deriving final ephemeral key');
        return context.deriveEphemeralKey(res.key);
      })
      .then((key) => {
        context.ephemeralKey = key;
        partialContexts.delete(this);
        this.logger.info('kms: derived final ephemeral key');
        return context;
      })
      .catch((reason) => {
        this.logger.error('kms: failed to negotiate ephemeral key', reason);
        return Promise.reject(reason);
      });
  }
});

export default KMS;
