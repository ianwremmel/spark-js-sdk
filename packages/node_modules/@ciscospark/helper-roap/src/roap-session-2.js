/* eslint-disable require-jsdoc */

import Events from 'ampersand-events';
import {wrap} from 'lodash';
import {Defer, Exception} from '@ciscospark/common';
import evented from '@ciscospark/common-evented';
import {safeSetTimeout} from '@ciscospark/common-timers';

import fromObject, {
  AnswerMessage,
  ErrorMessage,
  OfferMessage,
  OfferRequestMessage,
  OfferResponseMessage,
  OkMessage,
  RoapMessage
} from './messages';

class RoapException extends Exception {}
class InvalidStateError extends RoapException {
  constructor(currentState, expectedStates) {
    super(currentState, expectedStates);
  }

  parse(currentState, expectedStates) {
    return `Expected ${currentState} to be one of ${expectedStates.join(', ')}`;
  }
}

function validStates(states) {
  return function decorate(target, props, descriptor) {
    descriptor.value = wrap(descriptor.value, function wrapper(fn, ...args) {
      if (!states.includes(this.state)) {
        throw new InvalidStateError(this.state, states);
      }
      return Reflect.apply(fn, this, args);
    });
  };
}

// A note to the reader. This has been adapted from Linus's roap_session.cpp.
// Thanks to all the potential error conditions in a stateful, three-way
// handshaking  protocol like ROAP, that file is rather difficult to interpret
// (there are lots of switch statements; the unhappy paths make it difficult to
// find the  happy paths to wrap your head around how the protocol is intended
// to work).
//
// In an attempt to make this implementation easier to understand, unhappy paths
// are encapsulated in decorator functions, thus providing a clearer flow when
// things are working correctly.

function deferUntilState(session, state) {
  const defer = new Defer();

  session.on('change:state', onStateChange);

  return defer.promise;

  function onStateChange() {
    if (session.state === state) {
      defer.resolve(session.lastReceivedMessage);
      session.off('change:state', onStateChange);
    }
    // TODO if session.state === RoapSessionState.ERROR
  }
}

const RoapSessionState = {
  INIT: 'INIT',
  INIT_WAIT_RX_OFFER: 'INIT_WAIT_RX_OFFER',
  INIT_WAIT_RX_ANSWER: 'INIT_WAIT_RX_ANSWER',
  WAIT_TX_OFFER: 'WAIT_TX_OFFER',
  WAIT_TX_ANSWER: 'WAIT_TX_ANSWER',
  WAIT_TX_OK: 'WAIT_TX_OK',
  WAIT_RX_OFFER: 'WAIT_RX_OFFER',
  WAIT_RX_ANSWER: 'WAIT_RX_ANSWER',
  WAIT_RX_ANSWER_RESPONSE: 'WAIT_RX_ANSWER_RESPONSE',
  WAIT_RX_OK: 'WAIT_RX_OK',
  IDLE_LOCAL_OFFER: 'IDLE_LOCAL_OFFER',
  IDLE_REMOTE_OFFER: 'IDLE_REMOTE_OFFER',
  ERROR: 'ERROR'
};

/**
 * Adapted from the Linus ROAP Session. Manages state processing for the ROAP
 * messages associated with a given call.
 */
export default class RoapSession {
  static State = RoapSessionState

  retransmitDuration = 5000;

  retransmitTimer;

  @evented
  state = RoapSessionState.INIT;

  seq = 0;

  transactionTimeoutDuration = 90000;

  transactionTimeoutTimer;

  /**
   * constructor
   * @private
   * @param {Logger} logger
   */
  constructor({logger = console} = {}) {
    this.logger = logger;

    this.state = RoapSessionState.INIT;

    this.on('change:state', (next, previous) => {
      this.logger.info(`transitioned from ${previous} to ${next}`);
    });
  }

  /**
   * Retransmits the last message for the current state
   * @private
   */
  processRetransmitTimer() {
    // TODO
  }

  /**
   * Signals we've waited long enough and the transaction should be aborted.
   * @private
   */
  processTransactionTimeoutTimer() {
    // TODO
  }

  receive(raw) {
    const msg = raw instanceof RoapMessage ? raw : fromObject(raw);
    msg.session = this;

    if (msg instanceof AnswerMessage) {
      this.receiveAnswer(msg);
    }
  }

  @validStates([
    RoapSessionState.INIT_WAIT_RX_ANSWER,
    RoapSessionState.WAIT_TX_OK,
    RoapSessionState.WAIT_RX_ANSWER_RESPONSE,
    RoapSessionState.WAIT_RX_ANSWER,
    RoapSessionState.IDLE_LOCAL_OFFER
  ])
  receiveAnswer(msg) {
    this.lastReceivedMessage = msg;
    this.state = RoapSessionState.WAIT_TX_OK;
  }

  scheduleRetransmitTimer() {
    this.retransmitTimer = safeSetTimeout(() => this.processRetransmitTimer(), this.retransmitDuration);
  }

  scheduleTransactionTimeoutTimer() {
    this.transactionTimeoutTimer = safeSetTimeout(() => this.processTransactionTimeoutTimer(), this.transactionTimeoutDuration);
  }

  startTransction() {
    this.seq += 1;

    // schedule timers for retransmission and transaction timeout
    this.scheduleRetransmitTimer();
    this.scheduleTransactionTimeoutTimer();
  }

  @validStates([
    RoapSessionState.INIT,
    RoapSessionState.IDLE_LOCAL_OFFER,
    RoapSessionState.IDLE_REMOTE_OFFER,
    RoapSessionState.WAIT_RX_OK,
    RoapSessionState.WAIT_TX_OFFER
  ])
  transmitOffer(sdp) {
    if (!sdp) {
      throw new Error('Cannot transmit OFFER without SDP');
    }

    if (this.state !== RoapSessionState.WAIT_TX_OFFER) {
      this.startTransction();
    }

    let msg;
    switch (this.state) {
      case RoapSessionState.INIT:
        msg = new OfferMessage({
          seq: this.seq,
          sdps: [sdp],
          deferred: deferUntilState(this, RoapSessionState.WAIT_TX_OK),
          session: this
        });
        this.state = RoapSessionState.INIT_WAIT_RX_ANSWER;
        break;
      case RoapSession.WAIT_TX_OFFER:
        msg = new OfferResponseMessage({
          seq: this.seq,
          sdps: [sdp],
          deferred: deferUntilState(this, RoapSessionState.WAIT_TX_OK),
          session: this
        });
        this.state = RoapSessionState.WAIT_RX_ANSWER_RESPONSE;
        break;
      default:
        msg = new OfferMessage({
          seq: this.seq,
          sdps: [sdp],
          deferred: deferUntilState(this, RoapSessionState.WAIT_TX_OK),
          session: this
        });
        this.state = RoapSessionState.WAIT_RX_ANSWER;
        break;
    }

    return msg;
  }

  @validStates([RoapSessionState.WAIT_TX_OK])
  transmitOk() {
    this.seq += 1;
    const msg = new OkMessage({seq: this.seq});
    this.logger.info(`transmitting OK message ${msg}`);
    this.transmit(msg);
    this.state = RoapSessionState.IDLE_LOCAL_OFFER;
  }

  /**
   * Used for sending messages not in the critical path (e.g. OK messages)
   * @private
   * @param {RoapMessage} msg
   */
  transmit(msg) {
    this.logger.info(`transmitting ${msg}`);
    this.emit('transmit', msg);
  }
}

Object.assign(RoapSession.prototype, Events);
