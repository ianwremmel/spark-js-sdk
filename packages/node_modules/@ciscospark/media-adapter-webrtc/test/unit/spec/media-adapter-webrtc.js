import {curry, find} from 'lodash';
import {parse} from 'sdp-transform';
import {assert} from '@ciscospark/test-helper-chai';
import {browserOnly} from '@ciscospark/test-helper-mocha';
import sinon from '@ciscospark/test-helper-sinon';

import MediaAdapterWebRTC, {webrtc} from '@ciscospark/media-adapter-webrtc';
const {boolToDirection} = webrtc;

import {mockAnswer, mockRenegotiate} from '../lib/offer-answer';
import {
  assertLocalMedia,
  assertRemoteMedia
} from '../lib/assertions';

function getExpectedMediaDirection(next, previous) {
  if (previous.includes(`recv`)) {
    if (next === `inactive`) {
      return `recvonly`;
    }
    if (next === `sendonly`) {
      return `sendrecv`;
    }
  }

  return next;
}

const backoffPattern = [0, 100, 200, 400, 800];

function retry(fn) {
  return backoffPattern.reduce((promise, delay) => {
    return promise.catch(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            resolve(fn());
          }
          catch (err) {
            reject(err);
          }
        }, delay);
      });
    });
  }, Promise.reject());
}

browserOnly(describe)(`media-adapter-webrtc`, function() {
  this.timeout(10000);
  describe(`MediaAdapterWebRTC`, () => {
    describe(`renegotiation`, () => {
      const audioStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const audioEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      audioStartStates.forEach((audioStart) => {
        audioEndStates.forEach((audioEnd) => {
          videoStartStates.forEach((videoStart) => {
            // all the complexity comes from building the `describe()` block
            // message
            // eslint-disable-next-line complexity
            videoEndStates.forEach((videoEnd) => {
              if (audioStart === `inactive` && videoStart === `inactive`) {
                // not a valid initial state
                return;
              }

              if (audioEnd === `inactive` && videoEnd === `inactive`) {
                return;
              }

              if (audioStart === audioEnd && videoStart === videoEnd) {
                // no changes, therefore nothing to test
                return;
              }

              const expectNewTrack = !audioStart.includes(`recv`) && audioEnd.includes(`recv`) || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);
              let expectToRenegotiate = !audioStart.includes(`send`) && audioEnd.includes(`send`);
              expectToRenegotiate = expectToRenegotiate || !videoStart.includes(`send`) && videoEnd.includes(`send`);
              expectToRenegotiate = expectToRenegotiate || !audioStart.includes(`recv`) && audioEnd.includes(`recv`);
              expectToRenegotiate = expectToRenegotiate || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);

              const message = `when ${[
                audioStart === audioEnd ? `audio is ${audioStart}` : `audio changes from ${audioStart} to ${audioEnd}`,
                videoStart === videoEnd ? `video is ${videoStart}` : `video changes from ${videoStart} to ${videoEnd}`
              ]
                .filter((m) => m)
                .join(` and `)}`;

              describe(message, () => {
                // Note: This describe block is stateful; `it()` statements must
                // execute in order.
                let adapter;
                before(() => {
                  adapter = new MediaAdapterWebRTC();
                  adapter.bandwidthLimit = {
                    audioBandwidthLimit: 64000,
                    videoBandwidthLimit: 1000000
                  };
                });

                after(() => {
                  adapter.stop();
                });

                it(`initiates a session with audio=${audioStart} and video=${videoStart}`, () => {
                  adapter.set({
                    audio: audioStart.includes(`send`),
                    offerToReceiveAudio: audioStart.includes(`recv`),
                    video: videoStart.includes(`send`),
                    offerToReceiveVideo: videoStart.includes(`recv`)
                  });

                  assert.lengthOf(adapter.localMediaStream.getTracks(), 0);
                  assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);

                  return adapter.createOffer()
                    .then((offer) => {
                      assertLocalMedia(adapter, audioStart, videoStart);
                      assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);

                      assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      return offer;
                    })
                    .then(mockAnswer)
                    .then((answer) => {
                      assertLocalMedia(adapter, audioStart, videoStart);

                      assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);
                      assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));
                      assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (audioStart.includes(`recv`) || videoStart.includes(`recv`)) && new Promise((resolve) => adapter.once(`track`, resolve)),
                      adapter.acceptAnswer(answer)
                    ]))
                    .then(() => {
                      assertLocalMedia(adapter, audioStart, videoStart);
                      assertRemoteMedia(adapter, audioStart, videoStart);

                      assert.equal(adapter.audioDirection, audioStart);
                      assert.equal(adapter.videoDirection, videoStart);
                    });
                });

                it(`transitions to audio=${audioEnd} and video=${videoEnd}`, () => {
                  adapter.set({
                    audio: audioEnd.includes(`send`),
                    offerToReceiveAudio: audioEnd.includes(`recv`),
                    video: videoEnd.includes(`send`),
                    offerToReceiveVideo: videoEnd.includes(`recv`)
                  });

                  return Promise.all([
                    expectToRenegotiate && new Promise((resolve) => adapter.once(`negotiationneeded`, resolve))
                      .then(() => retry(() => assertLocalMedia(adapter, audioEnd, videoEnd)))
                      .then(() => adapter.createOffer())
                      .then((offer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a
                          // remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioEnd, audioStart));
                        }
                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), videoEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoEnd, videoStart));
                        }
                        return offer;
                      })
                      .then(mockRenegotiate)
                      .then((answer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioEnd));

                        }
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        catch (err) {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioEnd, audioStart)));
                        }

                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoEnd));
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoEnd, videoStart)));
                        }
                        return answer;
                      })
                      .then((answer) => adapter.acceptAnswer(answer)),
                    expectNewTrack && Promise.race([
                      new Promise((resolve) => adapter.once(`track`, resolve)),
                      new Promise((resolve, reject) => setTimeout(() => reject(new Error(`Expected track not added`)), 40000))
                    ])
                  ])
                  .then(() => {
                    assertLocalMedia(adapter, audioEnd, videoEnd);
                    assertRemoteMedia(adapter, audioEnd, videoEnd);
                    assert.equal(adapter.audioDirection, audioEnd);
                    assert.equal(adapter.videoDirection, videoEnd);
                  });
                });

                it.skip(`returns to audio=${audioStart} and video=${videoStart}`, () => {
                  const needsLocalAudioTrack = audioStart.includes(`send`) && adapter.localMediaStream.getAudioTracks().length === 0;
                  const needsLocalVideoTrack = videoStart.includes(`send`) && adapter.localMediaStream.getVideoTracks().length === 0;
                  const needsRemoteAudioTrack = audioStart.includes(`recv`) && adapter.remoteMediaStream.getAudioTracks().length === 0;
                  const needsRemoteVideoTrack = videoStart.includes(`recv`) && adapter.remoteMediaStream.getVideoTracks().length === 0;
                  const expectToRenegotiateOnReturn = needsLocalAudioTrack || needsLocalVideoTrack || needsRemoteAudioTrack || needsRemoteVideoTrack;

                  adapter.set({
                    audio: audioStart.includes(`send`),
                    offerToReceiveAudio: audioStart.includes(`recv`),
                    video: videoStart.includes(`send`),
                    offerToReceiveVideo: videoStart.includes(`recv`)
                  });

                  return Promise.resolve(expectToRenegotiateOnReturn && new Promise((resolve) => adapter.once(`negotiationneeded`, resolve))
                    .then(() => adapter.createOffer())
                    .then((offer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a
                        // remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioStart, audioEnd));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoStart, videoEnd));
                      }

                      return offer;
                    })
                    .then(mockRenegotiate)
                    .then((answer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));

                      }
                      // Need to fallback since firefox can't remove a remote stream but chrome can
                      catch (err) {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioStart, audioEnd)));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoStart, videoEnd)));
                      }

                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (needsRemoteAudioTrack || needsRemoteVideoTrack) && new Promise((resolve) => adapter.once(`track`, resolve)),
                      adapter.acceptAnswer(answer)
                    ])))
                    .then(() => {
                      assertLocalMedia(adapter, audioStart, videoStart);
                      assertRemoteMedia(adapter, audioStart, videoStart);

                      assert.equal(adapter.audioDirection, audioStart);
                      assert.equal(adapter.videoDirection, videoStart);
                    });
                });
              });
            });
          });
        });
      });
    });

    // [
    //   `audio`,
    //   `video`
    // ]
    // .forEach((kind) => {
    //   describe(`#(un)pauseSendingMedia(${kind})`, () => {
    //     it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
    //       const adapter = new MediaAdapterWebRTC();
    //       adapter.bandwidthLimit = {
    //         audioBandwidthLimit: 64000,
    //         videoBandwidthLimit: 1000000
    //       };
    //       adapter.set({
    //         audio: true,
    //         offerToReceiveAudio: true,
    //         video: true,
    //         offerToReceiveVideo: true
    //       });
    //       const spy = sinon.spy();

    //       return adapter.createOffer()
    //         .then(mockAnswer)
    //         .then((answer) => Promise.all([
    //           new Promise((resolve) => adapter.once(`track`, resolve)),
    //           adapter.acceptAnswer(answer)
    //         ]))
    //         .then(() => {
    //           assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //           assertRemoteMedia(adapter, `sendrecv`, `sendrecv`);

    //           adapter.on(`negotiationneeded`, spy);
    //           adapter.pauseSendingMedia(kind);
    //           assert.isFalse(adapter.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
    //           assert.isFalse(adapter.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
    //           // I don't know a better way to assert an event doesn't fire than
    //           // to wait a while and assert it didn't fire.
    //           return new Promise((resolve) => setTimeout(resolve, 500));
    //         })
    //         .then(() => assert.notCalled(spy))
    //         .then(() => {
    //           assertLocalMedia(adapter, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);
    //           assertRemoteMedia(adapter, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);

    //           adapter.on(`negotiationneeded`, spy);
    //           adapter.unpauseSendingMedia(kind);
    //           assert.isTrue(adapter.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
    //           assert.isTrue(adapter.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
    //           // I don't know a better way to assert an event doesn't fire than
    //           // to wait a while and assert it didn't fire.
    //           return new Promise((resolve) => setTimeout(resolve, 500));
    //         })
    //         .then(() => assert.notCalled(spy));
    //     });
    //   });

    //   describe(`#(un)pauseReceivingMedia(${kind})`, () => {
    //     it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
    //       const adapter = new MediaAdapterWebRTC();
    //       adapter.bandwidthLimit = {
    //         audioBandwidthLimit: 64000,
    //         videoBandwidthLimit: 1000000
    //       };
    //       adapter.set({
    //         audio: true,
    //         offerToReceiveAudio: true,
    //         video: true,
    //         offerToReceiveVideo: true
    //       });
    //       const spy = sinon.spy();

    //       return adapter.createOffer()
    //         .then(mockAnswer)
    //         .then((answer) => Promise.all([
    //           new Promise((resolve) => adapter.once(`track`, resolve)),
    //           adapter.acceptAnswer(answer)
    //         ]))
    //         .then(() => {
    //           assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //           assertRemoteMedia(adapter, `sendrecv`, `sendrecv`);

    //           adapter.on(`negotiationneeded`, spy);
    //           adapter.pauseReceivingMedia(kind);
    //           assert.isFalse(adapter.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
    //           assert.isFalse(adapter.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
    //           // I don't know a better way to assert an event doesn't fire than
    //           // to wait a while and assert it didn't fire.
    //           return new Promise((resolve) => setTimeout(resolve, 500));
    //         })
    //         .then(() => assert.notCalled(spy))
    //         .then(() => {
    //           assertLocalMedia(adapter, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);
    //           assertRemoteMedia(adapter, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);

    //           adapter.on(`negotiationneeded`, spy);
    //           adapter.unpauseReceivingMedia(kind);
    //           assert.isTrue(adapter.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
    //           assert.isTrue(adapter.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
    //           // I don't know a better way to assert an event doesn't fire than
    //           // to wait a while and assert it didn't fire.
    //           return new Promise((resolve) => setTimeout(resolve, 500));
    //         })
    //         .then(() => assert.notCalled(spy));
    //     });
    //   });

    // });

    // describe(`custom track`, () => {
    //   let adapter;
    //   beforeEach(() => {
    //     adapter = new MediaAdapterWebRTC();
    //     adapter.bandwidthLimit = {
    //       audioBandwidthLimit: 64000,
    //       videoBandwidthLimit: 1000000
    //     };
    //   });

    //   afterEach(() => {
    //     adapter.stop();
    //   });


    //   it.skip(`adds a track without internally calling getusermedia`, () => {
    //     let track;
    //     const spy = sinon.spy(adapter, `_getUserMedia`);

    //     return MediaAdapterWebRTC.getUserMedia({
    //       audio: true,
    //       video: false
    //     })
    //       .then((stream) => {
    //         track = stream.getAudioTracks()[0];
    //         adapter.setMedia(`audio`, `sendrecv`, track);

    //         assert.lengthOf(adapter.localMediaStream.getTracks(), 1);
    //         assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);

    //         return adapter.createOffer();
    //       })
    //       .then(mockAnswer)
    //       .then((answer) => Promise.all([
    //         new Promise((resolve) => adapter.once(`track`, resolve)),
    //         adapter.acceptAnswer(answer)
    //       ]))
    //       .then(() => {
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0].id, track.id);
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0], track);
    //         assert.notCalled(spy);
    //         assertLocalMedia(adapter, `sendrecv`, `inactive`);
    //       });
    //   });

    //   it.skip(`adds an external track without clobbering it`, () => {
    //     let track;

    //     return MediaAdapterWebRTC.getUserMedia({
    //       audio: true,
    //       video: false
    //     })
    //       .then((stream) => {
    //         track = stream.getAudioTracks()[0];
    //         adapter.setMedia(`audio`, `sendrecv`, track);
    //         adapter.setMedia(`video`, `sendrecv`);

    //         assert.lengthOf(adapter.localMediaStream.getTracks(), 1);
    //         assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);

    //         return adapter.createOffer();
    //       })
    //       .then(mockAnswer)
    //       .then((answer) => Promise.all([
    //         new Promise((resolve) => adapter.once(`track`, resolve)),
    //         adapter.acceptAnswer(answer)
    //       ]))
    //       .then(() => {
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0].id, track.id);
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0], track);
    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //       });
    //   });

    //   it.skip(`adds a new track to an inprogress connection`, () => {
    //     let track;

    //     adapter.setMedia(`audio`, `inactive`);
    //     adapter.setMedia(`video`, `sendrecv`);

    //     assert.lengthOf(adapter.localMediaStream.getTracks(), 0);
    //     assert.lengthOf(adapter.remoteMediaStream.getTracks(), 0);

    //     return adapter.createOffer()
    //       .then(mockAnswer)
    //       .then((answer) => Promise.all([
    //         new Promise((resolve) => adapter.once(`track`, resolve)),
    //         adapter.acceptAnswer(answer)
    //       ]))
    //       .then(() => {
    //         assertLocalMedia(adapter, `inactive`, `sendrecv`);
    //         return MediaAdapterWebRTC.getUserMedia({
    //           audio: true,
    //           video: false
    //         });
    //       })
    //       .then((stream) => {
    //         track = stream.getAudioTracks()[0];
    //         assert.isDefined(track);
    //         adapter.setMedia(`audio`, `sendrecv`, track);
    //         return new Promise((resolve) => adapter.once(`negotiationneeded`, resolve));
    //       })
    //       .then(() => adapter.createOffer())
    //       .then(mockRenegotiate)
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0].id, track.id);
    //         assert.equal(adapter.localMediaStream.getAudioTracks()[0], track);
    //       });
    //   });
    // });

    // describe(`custom constraints`, () => {
    //   let adapter, spy;
    //   beforeEach(() => {
    //     adapter = new MediaAdapterWebRTC();
    //     adapter.bandwidthLimit = {
    //       audioBandwidthLimit: 64000,
    //       videoBandwidthLimit: 1000000
    //     };
    //     spy = sinon.spy(MediaAdapterWebRTC, `getUserMedia`);
    //   });

    //   afterEach(() => {
    //     adapter.stop();
    //     spy.restore();
    //   });


    //   it(`starts a connection with custom constraints`, () => {
    //     assert.notCalled(spy);
    //     adapter.set({
    //       audio: true,
    //       offerToReceiveAudio: true,
    //       video: {
    //         facingMode: {
    //           ideal: `user`
    //         }
    //       },
    //       offerToReceiveVideo: true
    //     });

    //     return adapter.createOffer()
    //       .then((offer) => {
    //         return mockAnswer(offer);
    //       })
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assert.calledOnce(spy);
    //         assert.calledWith(spy, {
    //           audio: true,
    //           fake: true,
    //           video: {
    //             facingMode: {
    //               ideal: `user`
    //             }
    //           }
    //         });

    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //       });
    //   });

    //   it(`replaces a track with with new contraints`, () => {
    //     assert.notCalled(spy);
    //     adapter.set({
    //       audio: true,
    //       offerToReceiveAudio: true,
    //       video: {
    //         facingMode: {
    //           ideal: `user`
    //         }
    //       },
    //       offerToReceiveVideo: true
    //     });

    //     return adapter.createOffer()
    //       .then((offer) => {
    //         return mockAnswer(offer);
    //       })
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assert.calledOnce(spy);
    //         assert.calledWith(spy, {
    //           audio: true,
    //           fake: true,
    //           video: {
    //             facingMode: {
    //               ideal: `user`
    //             }
    //           }
    //         });

    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //         adapter.set({
    //           video: {
    //             facingMode: {
    //               ideal: `environment`
    //             }
    //           }
    //         });

    //         return new Promise((resolve) => adapter.once(`negotiationneeded`, resolve));
    //       })
    //       .then(() => adapter.createOffer())
    //       .then(mockAnswer)
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assert.calledWith(spy, {
    //           video: {
    //             facingMode: {
    //               ideal: `environment`
    //             }
    //           }
    //         });

    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //       });
    //   });

    //   it(`adds a new track to an inprogress connection`, () => {
    //     assert.notCalled(spy);
    //     adapter.set({audio: true, offerToReceiveAudio: true});
    //     return adapter.createOffer()
    //       .then((offer) => {
    //         return mockAnswer(offer);
    //       })
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assert.calledOnce(spy);

    //         assertLocalMedia(adapter, `sendrecv`, `inactive`);
    //         adapter.set({
    //           video: {
    //             facingMode: {
    //               ideal: `environment`
    //             }
    //           },
    //           offerToReceiveVideo: true
    //         });

    //         return new Promise((resolve) => adapter.once(`negotiationneeded`, resolve));
    //       })
    //       .then(() => adapter.createOffer())
    //       .then(mockAnswer)
    //       .then((answer) => adapter.acceptAnswer(answer))
    //       .then(() => {
    //         assert.calledWith(spy, {
    //           video: {
    //             facingMode: {
    //               ideal: `environment`
    //             }
    //           }
    //         });

    //         assertLocalMedia(adapter, `sendrecv`, `sendrecv`);
    //       });
    //   });
    // });
  });
});

/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromSDP(kind, sdp) {
  const media = find(parse(sdp).media, {type: kind});
  if (!media) {
    return `inactive`;
  }

  return media.direction;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} direction
 * @protected
 * @returns {string}
 */
export function reverseMediaDirection(direction) {
  switch (direction) {
  case `inactive`:
  case `sendrecv`:
    return direction;
  case `sendonly`:
    return `recvonly`;
  case `recvonly`:
    return `sendonly`;
  default:
    throw new Error(`direction "${direction}" is not valid`);
  }
}

/**
 * Checks a given sdp to ensure it contains an offer for the h264 codec
 * @param {boolean} wantsVideo
 * @param {string} offer
 * @protected
 * @returns {string} returns the offer to simplify use in promise chains
 */
export const ensureH264 = curry((wantsVideo, offer) => {
  if (wantsVideo) {
    if (!offer.includes(`m=video`)) {
      throw new Error(`No video section found in offer`);
    }
    if (!/[hH]264/.test(offer)) {
      throw new Error(`Offer does not include h264 codec`);
    }
  }
  return offer;
});

/**
 * Adds a bandwith limit line to the sdp; without this line, calling fails
 * @param {string} sdp SDP
 * @protected
 * @returns {string} The modified SDP
 */
export function limitBandwith(sdp) {
  return sdp.split(`\r\n`).reduce((lines, line) => {
    lines.push(line);
    if (line.startsWith(`m=`)) {
      lines.push(`b=TIAS:${line.includes(`audio`) ? 64000 : 1000000}`);
    }
    return lines;
  }, []).join(`\r\n`);
}

/**
 * Helper for dealing wait capitalization
 * @param {string} kind audio|video
 * @protected
 * @returns {string} Audio|Video
 */
export function kindToPropertyFragment(kind) {
  return kind === `audio` ? `Audio` : `Video`;
}

/**
 * Like get getMediaDirectionFromSDP, but reverses the the result
 * @param {string} kind
 * @param {string} offerSdp
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {
  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));
}

/**
 * Determines the flow of media for a given kind of media on a peer connection
 * @param {string} kind
 * @param {RTCPeerConnection} pc
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromTracks(kind, pc) {
  let send = false;
  // removeTrack isn't polyfilled in Chrome, which means getSenders can't be
  // trusted. We'll need to fallback to reading the track.
  if (pc.removeTrack) {
    const senders = pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    send = senders.length > 0 && senders.reduce((acc, s) => acc && s.track.enabled, true);
  }
  else {
    const localStreams = pc.getLocalStreams();
    send = localStreams.length > 0 && localStreams.reduce((acc1, stream) => {
      const tracks = stream
        .getTracks()
        .filter((t) => t.kind === kind);

      return acc1 && tracks.length > 0 && tracks.reduce((acc, t) => acc && t.enabled, true);
    }, true);
  }

  const remoteStreams = pc.getRemoteStreams();
  const recv = remoteStreams.length > 0 && remoteStreams.reduce((acc1, stream) => {
    const tracks = stream
      .getTracks()
      .filter((t) => t.kind === kind);

    return acc1 && tracks.length > 0 && tracks.reduce((acc, t) => acc && t.enabled, true);
  }, true);

  return boolToDirection(send, recv);
}
