# @ciscospark/internal-plugin-encryption

[![standard-readme compliant](https://img.shields.io/badge/readme%20style-standard-brightgreen.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)

> (internal-only) Encryption for Cisco Spark

This plugin provides encryption primitives (`encryptText`, `decryptBinary`, etc) and methods for interacting with a KMS by way of the Cisco Spark Encryption Service.

- [Security](#security)
- [Install](#install)
- [Usage](#usage)
- [Contribute](#contribute)
- [Maintainers](#maintainers)
- [License](#license)

## Security

Key-fetch round trips are expensive. This library supports optional on-disk caching; you'll need to weigh the performance benefits (mostly at app launch time) vs an increase in attack area when considering use of on-disk key caching. If you only need a few keys per user occasionally, you can probably do without caching, but if you're going to use a lot of the same keys regularly, the cache is going save you _a lot_ of perceived user time.

See [Storage Layer](guides/storage-layer/) for more details on how the storage system works. Encryption Keys are written to `unboundedStorage` which is an in-memory store by default. If you install the entirety of `ciscospark` and use it in a web browser, then `unboundedStorage` will be [indexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API).

## Install

```bash
npm install @ciscospark/spark-core @ciscospark/internal-plugin-encryption @ciscospark/plugin-logger
```

## Usage

> The examples below skip over getting an access token. We've got enough different ways to do so that you'll want to consult the authorization plugins, developer portal, or api docs to determine what method is appropriate to your use case. This comment `// DO AUTH HERE` indicates where you should authorize your spark instance in these examples.

### Encrypt and Decrypt Text

```js
import '@ciscospark/internal-plugin-encryption';
import '@ciscospark/plugin-logger';
import SparkCore from '@ciscospark/spark-core';

const spark = new SparkCore();

// DO AUTH HERE

const plaintext = 'foo';

// First, connect to mercury so we can receive KMS message responses
spark.mercury.connect()
// Now that we're connected, we can interact with the KMS

// Let's encrypt some text to store in our backend, then fetch it and
// decrypt it.

// First, we'll get a new encryption key
  .then(() => spark.internal.encryption.kms.createUnboundKeys({count: 1})
    // Now we'll use that key to create a new KMS resource object. Note the
    // array notation around "key". Explanation of when to create and reuse a
    // KRO is beyond the scope of this document and depends on your use-case.
    .then(([key]) => spark.internal.encryption.kms.createResource({
      userIds: [],
      key
    })
      // And now that the KRO is created, we can use the key to encryption are
      // message
      .then((kro) => spark.encryption.encryptText(key, plaintext)
        // and let's store the the ciphertext (and everything we'll need to
        // decrypt it) in our backend
        .then((ciphertext) => fetch('https://example.com/crypto/1', {
          body: JSON.stringify({
            ciphertext,
            keyUrl: key.keyUrl,
            kroUrl: kro.url
          }),
          method: 'POST'
        })))))
  // Let's assume some time has passed. Maybe we've refreshed our app and
  // plaintext isnt available any more. We'll need to retrieve the payload we
  // just stored and decrypt it
  .then(() => fetch('https://example.com/crypto/1'))
  .then((res) => res.json())
  .then((body) => spark.internal.encryption.decryptText(body.keyUrl, body.ciphertext))
  .then((retrievedPlainText) => {
    console.log(retrievedPlainText);
  });
```

### Encrypt, Store, Retrieve, and Decrypt a binary file

```js
import '@ciscospark/internal-plugin-encryption';
import '@ciscospark/plugin-logger';
import SparkCore from '@ciscospark/spark-core';

const spark = new SparkCore();

// DO AUTH HERE

// Let's just create a fake file. You'll probably want to do something like
// fs.readFile() (or fs.readFileSync())
const file = Buffer.alloc(1024);

// First, connect to mercury so we can receive KMS message responses
spark.mercury.connect()
  // Now that we're connected, we can interact with the KMS

  // Let's encrypt some text to store in our backend, then fetch it and decrypt
  // it.

  // First, we'll get a new encryption key
  .then(() => spark.internal.encryption.kms.createUnboundKeys({count: 1}))
  // Now we'll use that key to create a new KMS resource object. Note the array
  // notation around "key".
  .then(([key]) => spark.internal.encryption.kms.createResource({
    userIds: [],
    key
  })
    // And now that the KRO is created, we'll encrypt the file. Note that we're
    // not using the encryption key yet.
    .then((kro) => spark.encryption.encryptBinary(file)
      .then(({scr, cdata}) => {
        // now we've got an unencrypted scr and an encrypted file. The file was
        // encrypted locally with a symmetric key that's stored in the scr.
        // Let's upload the file

        const fd = new FormData();
        fd.append('file', cdata);

        return fetch('https://example.com/files/upload', {body: fd})
          .then((res) => res.json())
          .then((body) => {
            // We need to tell the scr where we stored the file. Depending on
            // your backend, you may know that when you upload it or you might
            // have to get it from response after uploading.
            scr.loc = body.location;

            // Now that we have all teh details for the scr, we can encrypt it.
            // This is where our key comes into play.
            return spark.internal.encryption.encryptScr(key, scr);
          })
          // Finally we've got everything encrypted and we can store the scr for
          // future use
          .then((encryptedScr) => fetch('https://exmaple.com/scrs/1', {
            body: JSON.stringify({
              encryptedScr,
              keyUrl: key.url,
              kroUrl: kro.url
            }),
            method: 'POST'
          }));
      })))

  // Again, let's assume some time has passed and all we know about the file we
  // stored is the scr url
  .then(() => fetch('https://exmaple.com/scrs/1'))
  .then((res) => res.json())
  .then((body) => spark.internal.encryption.decryptScr(body.keyUrl, body.encryptedScr))
  // The decrypted scr contains enough information to both download and decrypt
  // the file, so we can deal with that all in a single operation.
  .then((scr) => spark.internal.encryption.download(scr))
  .then((buf) => {
    console.log(buf);
  });
```

## Maintainers

This package is maintained by [Cisco Spark for Developers](https://developer.ciscospark.com/).

## Contribute

Pull requests welcome. Please see [CONTRIBUTING.md](../../CONTRIBUTING.md) for more details.

## License

Â© 2016-2018 Cisco and/or its affiliates. All Rights Reserved.
