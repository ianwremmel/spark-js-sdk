/* eslint-disable no-console */

const fs = require(`fs`);

const Base = require(`mocha/lib/reporters/base`);
const {defaults, pick, wrap} = require(`lodash`);
const mkdirp = require(`mkdirp`);
const path = require(`path`);
const xml = require(`xml`);

const consoleMethodNames = [`error`, `warn`, `log`, `info`, `debug`, `trace`];
const originalMethods = pick(console, consoleMethodNames);

/**
 * @typedef {Object} XUnitReporterOptions
 * @property {boolean} [collectLogs=true] - capture console logs (only works in `it()` blocks at this time)
 * @property {boolean} [suppressLogs=false] - do not print logs to the console
 * @property {string} [output='mocha.xml']
 * @property {string} [suite='Mocha Tests']
 * @property {string} [className] - supply your own function for setting the xunit className field. Defaults to `test.parent.fullTitle()`
 */

/**
 * @typedef {Object} MochaOptions
 * @property {XUnitReportOptions} reporterOptions
 */

/**
 * Mocha XUnit Report
 */
class XUnit extends Base {
  /**
   *
   * @param {Runner} runner
   * @param {MochaOptions} options
   * @returns {undefined}
   */
  constructor(runner, options = {
    reporterOptions: {
      collectLogs: true,
      suppressLogs: false,
      output: `mocha.xml`,
      suite: `Mocha Tests`,
      className: ``
    }
  }) {
    super(runner);

    this.options = options;

    runner.on(`pending`, (...args) => this.onPending(...args));
    runner.on(`pass`, (...args) => this.onPass(...args));
    runner.on(`fail`, (...args) => this.onFail(...args));
    runner.on(`test`, (...args) => this.onTest(...args));
    runner.on(`test end`, (...args) => this.onTestEnd(...args));

    this.data = {
      testsuite: [
        {_attr: {
          name: this.options.reporterOptions.suite || `Mocha Tests`,
          tests: 0,
          failures: 0,
          errors: 0,
          skipped: 0,
          timestamp: (new Date()).toUTCString()
        }}
      ]
    };

  }

  @throwsafe
  /**
   * @param {Test} test
   * @param {Object} extra
   * @returns {undefined}
   */
  prepareTestEntry(test, extra) {
    return defaults({
      name: `${test.parent.fullTitle()} ${test.title}`,
      classname: this.options.reporterOptions.className || test.parent.fullTitle(),
      time: test.duration / 1000 || 0
    }, extra);
  }

  @throwsafe
  /**
   * @param {Test} test
   * @returns {undefined}
   */
  onPending(test) {
    this.data.testsuite[0]._attr.tests += 1;
    this.data.testsuite[0]._attr.skipped += 1;

    this.data.testsuite.push({
      testcase: [{_attr: this.prepareTestEntry(test, {})}, {skipped: {}}]
    });
  }

  @throwsafe
  /**
   * @param {Test} test
   * @returns {undefined}
   */
  onPass(test) {
    this.data.testsuite[0]._attr.tests += 1;

    this.data.testsuite.push({
      testcase: {_attr: this.prepareTestEntry(test, {})}
    });
  }

  @throwsafe
  /**
   * @param {Test} test
   * @returns {undefined}
   */
  onFail(test) {
    this.data.testsuite[0]._attr.tests += 1;
    this.data.testsuite[0]._attr.failures += 1;

    this.data.testsuite.push({
      testcase: [
        {_attr: this.prepareTestEntry(test, {})},
        {failure: {
          _cdata: test.err.message
        }},
        {'system-out': {
          // _cdata: test.systemOut.reduce(logsReducer)
          _cdata: test.systemOut.map((line) => line.join(` `)).join(`\n`)
        }},
        {'system-err': {
          // _cdata: test.systemErr.reduce(logsReducer)
          _cdata: test.systemErr.map((line) => line.join(` `)).join(`\n`)
        }}
      ]
    });
  }

  @throwsafe
  /**
   * @param {Test} test
   * @returns {undefined}
   */
  onTest(test) {
    test.systemErr = [];
    test.systemOut = [];

    consoleMethodNames.forEach((methodName) => {
      if (!console[methodName]) {
        methodName = `log`;
      }

      const method = originalMethods[methodName];

      console[methodName] = (...args) => {
        if (!this.options.reporterOptions.suppressLogs) {
          Reflect.apply(method, console, args);
        }

        if (!this.options.reporterOptions.collectLogs) {
          return;
        }
        if (methodName === `error`) {
          test.systemErr.push(args);
        }
        else {
          test.systemOut.push([`${methodName.toUpperCase()}:`, ...args]);
        }
      };

      console[methodName].unwrap = () => {
        console[methodName] = method;
      };
    });
  }

  @throwsafe
  /**
   * @returns {undefined}
   */
  onTestEnd() {
    consoleMethodNames.forEach((methodName) => console[methodName] && console[methodName].unwrap && console[methodName].unwrap());
  }

  @throwsafe
  /**
   * @param {number} failures
   * @param {Function} done
   * @returns {undefined}
   */
  done(failures, done) {
    const out = xml(this.data, {
      indent: true
    });
    mkdirp.sync(path.dirname(this.options.reporterOptions.output));
    // eslint-disable-next-line no-sync
    fs.writeFileSync(this.options.reporterOptions.output, out);
    done(failures);
  }
}

module.exports = XUnit;

/**
 * Makes sure we log errors before ignoring them
 * @param {Constructor} target
 * @param {string} prop
 * @param {Object} descriptor
 * @returns {mixed}
 */
function throwsafe(target, prop, descriptor) {
  descriptor.value = wrap(descriptor.value, function wrapper(fn, ...args) {
    try {
      // eslint-disable-next-line no-invalid-this
      return Reflect.apply(fn, this, args);
    }
    catch (err) {
      process.stderr.write(`${err}\n`);
      return err;
    }
  });
}
